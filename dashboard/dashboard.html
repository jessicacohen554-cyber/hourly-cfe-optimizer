<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="robots" content="noindex, nofollow">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The 8,760 Problem â€” Cost Optimizer Dashboard</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;500;600;700&family=Plus+Jakarta+Sans:wght@400;500;600;700&family=Rajdhani:wght@400;500;600;700&family=Barlow+Semi+Condensed:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
@font-face {
    font-family: 'Franklin Gothic Demi';
    src: local('Franklin Gothic Demi'), local('Franklin Gothic Medium'), local('ITC Franklin Gothic Demi'), local('Franklin Gothic Demi Cond');
    font-weight: 600;
    font-style: normal;
    font-display: swap;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
<style>
/* ========== RESET & BASE ========== */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

html {
    font-size: 17px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

body {
    font-family: 'Plus Jakarta Sans', 'Helvetica Neue', Arial, sans-serif;
    background: #0F1A2E;
    background-image:
        radial-gradient(ellipse at 20% 0%, rgba(14,165,233,0.06) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 100%, rgba(245,158,11,0.04) 0%, transparent 50%);
    background-attachment: fixed;
    color: #000000;
    line-height: 1.55;
    min-height: 100vh;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* ========== VARIABLES ========== */
:root {
    --navy: #1A2744;
    --navy-light: #2D3A52;
    --bg-card: #FFFFFF;
    --bg-card-hover: #F7F8FA;
    --border: #D4D8E0;
    --border-light: #E5E7EB;
    --text-primary: #000000;
    --text-secondary: #000000;
    --text-muted: #6B7280;

    --clean-firm: #1E3A5F;
    --solar: #F59E0B;
    --wind: #22C55E;
    --hydro: #0EA5E9;
    --storage: #EF4444;
    --gap: #D1D5DB;
    --outline: #374151;
    --primary-grey: #6B7280;
    --secondary-grey: #9CA3AF;
    --red: #EF4444;
    --red-light: rgba(239, 68, 68, 0.08);
    --indigo: #1A2744;

    --clean-firm-70: rgba(30, 58, 95, 0.55);
    --solar-70: rgba(245, 158, 11, 0.55);
    --wind-70: rgba(34, 197, 94, 0.55);
    --hydro-70: rgba(14, 165, 233, 0.55);
    --storage-70: rgba(239, 68, 68, 0.55);
    --gap-70: rgba(209, 213, 219, 0.55);
}

/* ========== TOP NAVIGATION BAR ========== */
.top-nav {
    background: #1a1a2e;
    padding: 0 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: sticky;
    top: 0;
    z-index: 999;
    border-bottom: 1px solid rgba(255,255,255,0.08);
    min-height: 48px;
}
.top-nav-inner {
    display: flex;
    align-items: center;
    gap: 0;
    max-width: 1440px;
    width: 100%;
    justify-content: center;
}
.top-nav a {
    color: rgba(255,255,255,0.75);
    text-decoration: none;
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', sans-serif;
    font-size: 0.85rem;
    font-weight: 600;
    letter-spacing: 0.04em;
    padding: 14px 18px;
    transition: color 0.2s, background 0.2s, border-color 0.2s;
    border-bottom: 3px solid transparent;
    white-space: nowrap;
}
.top-nav a:hover {
    color: #ffffff;
    background: rgba(255,255,255,0.06);
}
.top-nav a.nav-active {
    color: #ffffff;
    border-bottom-color: #0EA5E9;
    background: rgba(14,165,233,0.1);
}
.nav-hamburger {
    display: none;
    background: none;
    border: none;
    color: #ffffff;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 10px;
    min-width: 44px;
    min-height: 44px;
    align-items: center;
    justify-content: center;
}
.nav-hamburger svg {
    width: 24px;
    height: 24px;
    stroke: currentColor;
    stroke-width: 2;
    fill: none;
}
@media (max-width: 768px) {
    .top-nav {
        flex-wrap: wrap;
        padding: 0 12px;
        justify-content: space-between;
    }
    .top-nav-inner {
        display: none;
        flex-direction: column;
        width: 100%;
        padding-bottom: 8px;
    }
    .top-nav-inner.nav-open {
        display: flex;
    }
    .top-nav a {
        padding: 12px 16px;
        border-bottom: none;
        border-left: 3px solid transparent;
        width: 100%;
        text-align: left;
    }
    .top-nav a.nav-active {
        border-left-color: #0EA5E9;
        border-bottom: none;
        background: rgba(14,165,233,0.12);
    }
    .nav-hamburger {
        display: flex;
    }
    .nav-brand {
        display: flex;
        align-items: center;
        color: #ffffff;
        font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', sans-serif;
        font-size: 0.9rem;
        font-weight: 700;
        letter-spacing: 0.03em;
        padding: 12px 0;
    }
}
@media (min-width: 769px) {
    .nav-brand { display: none; }
}

/* ========== SENSITIVITY TOGGLES (5 Paired Groups) ========== */
.sensitivity-panel {
    background: var(--bg-card);
    border: 1px solid var(--border-light);
    border-radius: 10px;
    padding: 24px 28px;
    margin-bottom: 28px;
}
.sensitivity-panel h3 {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', sans-serif;
    font-weight: 600;
    font-size: 1.15rem;
    color: #DC2626;
    margin-bottom: 6px;
    letter-spacing: 0.04em;
}
.sensitivity-panel .sensitivity-subtitle {
    font-family: 'Plus Jakarta Sans', 'Helvetica Neue', Arial, sans-serif;
    font-size: 0.84rem;
    color: var(--text-muted);
    margin-bottom: 20px;
    line-height: 1.45;
}
.sensitivity-toggles-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(min(320px, 100%), 1fr));
    gap: 16px 28px;
}
.sensitivity-toggle-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    padding: 12px 16px;
    background: #f8f9fb;
    border: 1px solid var(--border-light);
    border-radius: 8px;
    transition: border-color 0.15s ease, box-shadow 0.15s ease;
}
.sensitivity-toggle-item:hover {
    border-color: var(--border);
    box-shadow: 0 1px 4px rgba(0,0,0,0.04);
}
.sensitivity-toggle-item .toggle-label-area {
    display: flex;
    flex-direction: column;
    gap: 2px;
    min-width: 0;
    flex: 1;
}
.sensitivity-toggle-item .toggle-label-main {
    font-family: 'Plus Jakarta Sans', 'Helvetica Neue', Arial, sans-serif;
    font-size: 0.88rem;
    font-weight: 600;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 6px;
}
.sensitivity-toggle-item .toggle-label-sub {
    font-family: 'Plus Jakarta Sans', 'Helvetica Neue', Arial, sans-serif;
    font-size: 0.76rem;
    color: var(--text-muted);
    line-height: 1.35;
}
.info-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: rgba(107,114,128,0.12);
    color: var(--text-muted);
    font-size: 0.68rem;
    font-weight: 700;
    cursor: help;
    flex-shrink: 0;
    line-height: 1;
    position: relative;
}
/* Custom tooltip for info icons */
.info-icon-wrapper {
    position: relative;
    display: inline-flex;
}
.info-tooltip {
    display: none;
    position: absolute;
    bottom: calc(100% + 8px);
    left: 50%;
    transform: translateX(-50%);
    background: #1a1a2e;
    color: #ffffff;
    font-family: 'Plus Jakarta Sans', 'Helvetica Neue', Arial, sans-serif;
    font-size: 0.78rem;
    font-weight: 400;
    line-height: 1.45;
    padding: 10px 14px;
    border-radius: 8px;
    width: min(280px, 85vw);
    z-index: 100;
    box-shadow: 0 4px 16px rgba(0,0,0,0.18);
    pointer-events: none;
}
.info-tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: #1a1a2e;
}
.info-icon-wrapper:hover .info-tooltip,
.info-icon-wrapper:focus-within .info-tooltip {
    display: block;
}
.toggle-btn-group {
    display: inline-flex;
    border: 1.5px solid var(--border);
    border-radius: 6px;
    overflow: hidden;
    background: #f3f4f6;
    flex-shrink: 0;
}
.toggle-btn-group button {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', sans-serif;
    font-size: 0.82rem;
    font-weight: 600;
    padding: 8px 16px;
    min-width: 44px;
    min-height: 44px;
    border: none;
    background: transparent;
    color: var(--text-muted);
    cursor: pointer;
    transition: all 0.15s ease;
    letter-spacing: 0.02em;
}
.toggle-btn-group button:not(:last-child) {
    border-right: 1px solid var(--border-light);
}
.toggle-btn-group button.active {
    background: var(--navy);
    color: #ffffff;
}
.toggle-btn-group button:hover:not(.active) {
    background: rgba(26,39,68,0.08);
    color: var(--text-primary);
}
@media (max-width: 768px) {
    .sensitivity-toggles-grid {
        grid-template-columns: 1fr;
    }
    .sensitivity-toggle-item {
        flex-wrap: wrap;
        padding: 10px 12px;
    }
    .sensitivity-panel {
        padding: 18px 16px;
    }
    .info-tooltip {
        width: min(220px, 80vw);
        left: 0;
        transform: translateX(-20%);
    }
    .info-tooltip::after {
        left: 30%;
    }
}

/* ========== WHAT YOU NEED CHART ========== */
.wyn-chart-container {
    position: relative;
    height: 300px;
    margin-bottom: 16px;
}
.wyn-insight-box {
    background: linear-gradient(145deg, #f8f9fb 0%, #f0f2f5 100%);
    border: 1px solid var(--border-light);
    border-radius: 8px;
    padding: 14px 18px;
    font-size: 0.88rem;
    color: var(--text-secondary);
    line-height: 1.6;
}
.wyn-insight-box strong {
    color: var(--navy);
}

/* ========== WHAT YOU NEED PANEL ========== */
.what-you-need-panel {
    background: var(--bg-card);
    border: 1px solid var(--border-light);
    border-radius: 10px;
    padding: 28px;
    margin-bottom: 28px;
}
.what-you-need-panel h3 {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', sans-serif;
    font-weight: 600;
    font-size: 1.3rem;
    color: #DC2626;
    margin-bottom: 8px;
    letter-spacing: 0.04em;
}
.what-you-need-panel .wyn-subtitle {
    font-size: 0.88rem;
    color: var(--text-muted);
    margin-bottom: 20px;
    line-height: 1.5;
}
@media (max-width: 768px) {
    .what-you-need-panel { padding: 18px 16px; }
    .wyn-chart-container { height: 340px; }
}

/* ========== HEADER ========== */
.header {
    background: linear-gradient(135deg, #0F1A2E 0%, #122952 30%, #1565C0 70%, #0D47A1 100%);
    color: #ffffff;
    padding: 72px 24px 64px;
    text-align: center;
    position: relative;
    overflow: hidden;
}
/* Radial energy glows + dispatch stack curves (bottom) */
.header::before {
    content: '';
    position: absolute;
    inset: 0;
    z-index: 1;
    pointer-events: none;
    background:
        radial-gradient(ellipse 55% 70% at 12% 75%, rgba(14,165,233,0.4) 0%, transparent 65%),
        radial-gradient(ellipse 45% 60% at 38% 85%, rgba(34,197,94,0.35) 0%, transparent 60%),
        radial-gradient(ellipse 50% 65% at 62% 80%, rgba(245,158,11,0.35) 0%, transparent 60%),
        radial-gradient(ellipse 40% 55% at 88% 70%, rgba(239,68,68,0.3) 0%, transparent 55%),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 240' preserveAspectRatio='none'%3E%3Cdefs%3E%3ClinearGradient id='a1' x1='0' y1='0' x2='0' y2='1'%3E%3Cstop offset='0' stop-color='rgba(255,255,255,0.15)'/%3E%3Cstop offset='1' stop-color='rgba(255,255,255,0.01)'/%3E%3C/linearGradient%3E%3ClinearGradient id='a2' x1='0' y1='0' x2='0' y2='1'%3E%3Cstop offset='0' stop-color='rgba(34,197,94,0.35)'/%3E%3Cstop offset='1' stop-color='rgba(34,197,94,0.03)'/%3E%3C/linearGradient%3E%3ClinearGradient id='a3' x1='0' y1='0' x2='0' y2='1'%3E%3Cstop offset='0' stop-color='rgba(245,158,11,0.35)'/%3E%3Cstop offset='1' stop-color='rgba(245,158,11,0.03)'/%3E%3C/linearGradient%3E%3C/defs%3E%3Cpath d='M0,240 L0,130 C200,100 400,70 600,80 C800,90 1000,120 1200,100 L1200,240 Z' fill='url(%23a1)'/%3E%3Cpath d='M0,240 L0,160 C200,140 400,115 600,125 C800,135 1000,155 1200,140 L1200,240 Z' fill='url(%23a2)'/%3E%3Cpath d='M0,240 L0,190 C200,180 400,165 600,170 C800,175 1000,188 1200,180 L1200,240 Z' fill='url(%23a3)'/%3E%3Cpath d='M0,130 C200,100 400,70 600,80 C800,90 1000,120 1200,100' fill='none' stroke='rgba(255,255,255,0.45)' stroke-width='2'/%3E%3Cpath d='M0,160 C200,140 400,115 600,125 C800,135 1000,155 1200,140' fill='none' stroke='%2322C55E' stroke-width='2' stroke-opacity='0.6'/%3E%3Cpath d='M0,190 C200,180 400,165 600,170 C800,175 1000,188 1200,180' fill='none' stroke='%23F59E0B' stroke-width='2' stroke-opacity='0.6'/%3E%3C/svg%3E") no-repeat bottom center;
    background-size: 100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%;
}
/* Vibrant pulse lines (top) + dark text backing overlay */
.header::after {
    content: '';
    position: absolute;
    inset: 0;
    z-index: 1;
    pointer-events: none;
    background:
        radial-gradient(ellipse 70% 45% at 50% 45%, rgba(5,15,35,0.55) 0%, transparent 100%),
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 80' preserveAspectRatio='none'%3E%3Cpath d='M0,50 L250,50 L270,18 L288,68 L306,22 L324,60 L342,50 L1200,50' fill='none' stroke='rgba(14,165,233,0.5)' stroke-width='2'/%3E%3Cpath d='M0,35 L600,35 L618,10 L636,60 L654,14 L672,55 L690,35 L1200,35' fill='none' stroke='rgba(245,158,11,0.4)' stroke-width='2'/%3E%3C/svg%3E") no-repeat top center;
    background-size: 100% 100%, 100% 80px;
}
/* Accent bar */
.header-accent {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #1A2744 0%, #0EA5E9 25%, #22C55E 50%, #F59E0B 75%, #EF4444 100%);
    z-index: 2;
}
/* Logo removed for rebrand */
.header-logo {
    display: none;
}
.header h1 {
    font-family: 'Franklin Gothic Demi', 'Lexend', 'Rajdhani', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-weight: 700;
    font-size: 3.2rem;
    letter-spacing: 0.5px;
    text-transform: none;
    margin-bottom: 14px;
    position: relative;
    z-index: 3;
    text-shadow: 0 2px 20px rgba(0,0,0,0.5), 0 1px 3px rgba(0,0,0,0.3);
    line-height: 1.15;
}
.header .subtitle {
    font-family: 'Plus Jakarta Sans', 'Helvetica Neue', Arial, sans-serif;
    font-size: 1.15rem;
    font-weight: 400;
    opacity: 0.92;
    max-width: 660px;
    margin: 0 auto;
    letter-spacing: 0.2px;
    position: relative;
    z-index: 3;
    text-shadow: 0 2px 12px rgba(0,0,0,0.4), 0 1px 2px rgba(0,0,0,0.2);
    line-height: 1.55;
}
.header .data-year-label {
    font-size: 0.88rem;
    opacity: 0.6;
    margin-top: 8px;
    position: relative;
    z-index: 1;
}
/* Bottom accent bar */
.bottom-banner {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 6px;
    background: linear-gradient(90deg, #1A2744 0%, #0EA5E9 25%, #22C55E 50%, #F59E0B 75%, #EF4444 100%);
    z-index: 1000;
    overflow: hidden;
}
.bottom-banner::after {
    content: '';
    position: absolute;
    inset: 0;
    background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 6' preserveAspectRatio='none'%3E%3Cpath d='M0,3 L120,3 L135,0.5 L150,5.5 L165,1 L180,5 L195,3 L400,3 L415,0.5 L430,5.5 L445,1 L460,5 L475,3 L700,3 L715,0.5 L730,5.5 L745,1 L760,5 L775,3 L1000,3 L1015,0.5 L1030,5.5 L1045,1 L1060,5 L1075,3 L1200,3' fill='none' stroke='rgba(255,255,255,0.45)' stroke-width='1.2'/%3E%3C/svg%3E") no-repeat center center;
    background-size: 100% 100%;
    pointer-events: none;
}

/* ========== MAIN CONTENT ========== */
.main-content {
    max-width: 1440px;
    margin: 0 auto;
    padding: 32px 44px 64px;
    background: #F3F4F8;
    border-radius: 16px;
    box-shadow: 0 4px 24px rgba(0,0,0,0.12);
}

/* ========== CONTROLS ROW ========== */
.controls-row {
    display: flex;
    gap: 24px;
    align-items: flex-end;
    margin-bottom: 28px;
    flex-wrap: wrap;
}

.control-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.control-group label {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-weight: 600;
    font-size: 0.85rem;
    text-transform: capitalize;
    letter-spacing: 0.06em;
    color: var(--text-secondary);
}

.control-group select {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 1.0rem;
    padding: 11px 38px 11px 16px;
    border: 1.5px solid var(--border);
    border-radius: 8px;
    background: #FFFFFF;
    color: var(--text-primary);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='7' fill='none'%3E%3Cpath d='M1 1l5 5 5-5' stroke='%236B6356' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 12px center;
    min-width: min(220px, 100%);
    transition: border-color 0.2s, box-shadow 0.2s;
}

.control-group select:hover {
    border-color: var(--navy);
}

.control-group select:focus {
    outline: none;
    border-color: var(--navy);
    box-shadow: 0 0 0 3px rgba(26, 39, 68, 0.12);
}

.region-context {
    margin-left: auto;
    display: flex;
    gap: 28px;
    align-items: center;
    font-size: 0.92rem;
    color: var(--text-secondary);
}

.region-context span {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.region-context .ctx-label {
    font-size: 0.76rem;
    text-transform: capitalize;
    letter-spacing: 0.05em;
    color: var(--text-muted);
}

.region-context .ctx-value {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-weight: 600;
    color: var(--text-primary);
    font-size: 0.98rem;
}

/* ========== METRIC TILES ========== */
.metrics-row {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 18px;
    margin-bottom: 28px;
}

.metric-tile {
    background: linear-gradient(145deg, #1F3158 0%, #1A2744 100%);
    border: none;
    border-radius: 10px;
    padding: 20px 18px;
    text-align: center;
    transition: transform 0.3s cubic-bezier(0.34,1.56,0.64,1), box-shadow 0.3s;
    position: relative;
    overflow: hidden;
}

.metric-tile::after {
    content: '';
    position: absolute;
    top: -50%; left: -50%;
    width: 200%; height: 200%;
    background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 60%);
    pointer-events: none;
}

.metric-tile:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(26,39,68,0.3);
}

.metric-tile.tile-negative {
    background: linear-gradient(145deg, #F87171 0%, #EF4444 100%);
    border: none;
}

.metric-tile.tile-negative .tile-label,
.metric-tile.tile-negative .tile-sub {
    color: rgba(255,255,255,0.75);
    opacity: 1;
}

.metric-tile.tile-negative .tile-value {
    color: #FFFFFF;
}

.metric-tile.tile-negative:hover {
    box-shadow: 0 8px 24px rgba(239,68,68,0.3);
}

.metric-tile .tile-label {
    font-size: 0.8rem;
    text-transform: capitalize;
    letter-spacing: 0.06em;
    color: rgba(255,255,255,0.75);
    margin-bottom: 8px;
    font-weight: 600;
}

.metric-tile .tile-value {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 1.9rem;
    font-weight: 700;
    color: #FFFFFF;
    line-height: 1.1;
}

.metric-tile .tile-sub {
    font-size: 0.78rem;
    color: rgba(255,255,255,0.6);
    margin-top: 6px;
}

.metric-tile .tile-sub.accent {
    color: #FFFFFF;
    font-weight: 600;
    opacity: 1;
}

/* ========== CHART PANELS ========== */
.charts-row {
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 24px;
    margin-bottom: 28px;
}

.chart-panel {
    background: var(--bg-card);
    border: 1px solid var(--border-light);
    border-radius: 10px;
    padding: 28px;
}

.chart-panel.donut-panel {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.chart-panel h3 {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-weight: 600;
    font-size: 1.3rem;
    color: #DC2626;
    margin-bottom: 16px;
    text-transform: capitalize;
    letter-spacing: 0.04em;
}

.donut-container {
    position: relative;
    width: 90%;
    max-width: 260px;
    margin: 0 auto;
    padding: 8px;
    aspect-ratio: 1 / 1;
}

.donut-center-label {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    pointer-events: none;
}

.donut-center-label .dcl-value {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 2.2rem;
    font-weight: 700;
    color: var(--navy);
    line-height: 1;
}

.donut-center-label .dcl-label {
    font-size: 0.85rem;
    text-transform: capitalize;
    letter-spacing: 0.05em;
    color: var(--text-muted);
    margin-top: 4px;
}

.donut-legend {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 6px 14px;
    margin-top: 16px;
    font-size: 0.82rem;
    color: var(--text-secondary);
}

.donut-legend-item {
    display: flex;
    align-items: center;
    gap: 4px;
    white-space: nowrap;
}

.donut-legend-swatch {
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1.5px solid var(--outline);
    flex-shrink: 0;
}

.compressed-day-container {
    position: relative;
    height: 370px;
    overflow: hidden;
}

/* ========== COST BREAKDOWN ========== */
.cost-panel {
    background: var(--bg-card);
    border: 1px solid var(--border-light);
    border-radius: 10px;
    padding: 28px;
    margin-bottom: 28px;
}

.cost-panel h3 {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-weight: 600;
    font-size: 1.3rem;
    color: #DC2626;
    margin-bottom: 16px;
    text-transform: capitalize;
    letter-spacing: 0.04em;
}

.cost-table-wrapper {
    overflow-x: auto;
}

.cost-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.92rem;
}

.cost-table th {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-weight: 600;
    text-transform: capitalize;
    letter-spacing: 0.04em;
    font-size: 0.92rem;
    color: var(--text-primary);
    padding: 12px 14px;
    text-align: left;
    border-bottom: 2px solid var(--border);
}

.cost-table th:not(:first-child) {
    text-align: right;
}

.cost-table td {
    padding: 10px 14px;
    border-bottom: 1px solid var(--border-light);
    color: var(--text-primary);
}

.cost-table td:not(:first-child) {
    text-align: right;
    font-variant-numeric: tabular-nums;
}

.cost-table tr:last-child td {
    border-bottom: none;
}

.cost-table .row-total td {
    font-weight: 700;
    border-top: 2px solid var(--border);
    color: var(--navy);
}

.cost-table .resource-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    margin-right: 8px;
    border: 1.5px solid var(--outline);
    vertical-align: middle;
}

.cost-note {
    font-size: 0.8rem;
    color: var(--text-muted);
    margin-top: 14px;
    font-style: italic;
}

.cost-unavailable {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 120px;
    color: var(--text-muted);
    font-size: 0.9rem;
    font-style: italic;
}


/* ========== PEAK CAPACITY + COST ROW ========== */
.peak-cost-row {
    display: flex;
    gap: 24px;
    margin-bottom: 24px;
}

.peak-cost-row .peak-capacity-panel {
    flex: 0.7;
    margin-bottom: 0;
}

.peak-cost-row .cost-panel {
    flex: 1.3;
    margin-bottom: 0;
}

@media (max-width: 900px) {
    .peak-cost-row {
        flex-direction: column;
    }
}

/* ========== PEAK CAPACITY VISUAL ========== */
.peak-capacity-panel {
    background: var(--bg-card);
    border: 1px solid var(--border-light);
    border-radius: 10px;
    padding: 28px;
}

.peak-capacity-panel h3 {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-weight: 600;
    font-size: 1.3rem;
    color: #DC2626;
    margin-bottom: 16px;
    text-transform: capitalize;
    letter-spacing: 0.04em;
}

.peak-capacity-visual {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
}

.peak-tower-wrap {
    display: flex;
    align-items: flex-end;
    justify-content: center;
    gap: 24px;
    height: 320px;
    width: 100%;
    padding-top: 16px;
}

.peak-tower {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex: 1;
    max-width: 110px;
}

.peak-tower-value {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 0.95rem;
    font-weight: 700;
    color: var(--navy);
    white-space: nowrap;
    margin-bottom: 8px;
    text-align: center;
}

.peak-tower-bar {
    width: 100%;
    border-radius: 8px 8px 2px 2px;
    transition: height 0.6s cubic-bezier(0.34,1.56,0.64,1);
    min-height: 4px;
    box-sizing: border-box;
}

.peak-tower-label {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 0.82rem;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: capitalize;
    letter-spacing: 0.06em;
    text-align: center;
    line-height: 1.25;
    margin-top: 10px;
}

.peak-capacity-note {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 0.9rem;
    color: var(--text-muted);
    text-align: center;
    line-height: 1.55;
    max-width: 380px;
    margin-top: 8px;
}

.peak-capacity-note strong {
    color: var(--navy);
    font-weight: 700;
}

/* ========== SCROLL TRANSITION ========== */
.scroll-transition {
    padding: 64px 0 48px;
    text-align: center;
}

.scroll-transition-inner {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    padding: 40px 32px;
    background: linear-gradient(135deg, rgba(26,39,68,0.03) 0%, rgba(239,68,68,0.05) 50%, rgba(245,158,11,0.03) 100%);
    border: 1px solid rgba(26,39,68,0.12);
    border-radius: 16px;
    max-width: 560px;
    margin: 0 auto;
}

.scroll-transition-line {
    width: 2px;
    height: 40px;
    background: linear-gradient(to bottom, transparent, var(--clean-firm), transparent);
    border-radius: 1px;
}

.scroll-transition-text {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 1.43rem;
    font-weight: 600;
    color: #DC2626;
    letter-spacing: 0.01em;
    max-width: 440px;
    line-height: 1.55;
}

.scroll-transition-arrow {
    font-size: 2rem;
    color: var(--clean-firm);
    animation: bounceDown 1.8s ease-in-out infinite;
    opacity: 0.85;
    filter: drop-shadow(0 2px 6px rgba(26,39,68,0.25));
}

@keyframes bounceDown {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(10px); }
}

/* ========== TARGET MODE TOGGLE (Interim / Long-term) ========== */
.target-mode-panel {
    background: var(--bg-card);
    border: 1px solid var(--border-light);
    border-radius: 10px;
    padding: 18px 28px;
    margin-bottom: 28px;
    display: flex;
    align-items: center;
    gap: 24px;
    flex-wrap: wrap;
}
.target-mode-panel .target-mode-label {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', sans-serif;
    font-weight: 600;
    font-size: 0.92rem;
    color: var(--text-primary);
    white-space: nowrap;
}
.target-mode-toggle {
    display: flex;
    background: #E5E7EB;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border);
}
.target-mode-toggle button {
    padding: 10px 22px;
    border: none;
    background: transparent;
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', sans-serif;
    font-size: 0.88rem;
    font-weight: 600;
    color: var(--text-muted);
    cursor: pointer;
    transition: background 0.2s, color 0.2s;
    min-height: 44px;
    min-width: 44px;
}
.target-mode-toggle button.active {
    background: var(--navy);
    color: #FFFFFF;
}
.target-mode-toggle button:hover:not(.active) {
    background: rgba(26,39,68,0.1);
    color: var(--text-primary);
}
.target-mode-info {
    font-size: 0.8rem;
    color: var(--text-muted);
    flex: 1;
    min-width: 200px;
}
.target-mode-info strong {
    color: var(--text-primary);
}

/* ========== HEATMAP TILE COLORS (5-group red-to-green, solid) ========== */
.metric-tile.heatmap-1 {
    background: #15803D !important;
    border: none;
}
.metric-tile.heatmap-1 .tile-label,
.metric-tile.heatmap-1 .tile-sub { color: #fff !important; }
.metric-tile.heatmap-1 .tile-value { color: #fff !important; }
.metric-tile.heatmap-2 {
    background: #3F8F4F !important;
    border: none;
}
.metric-tile.heatmap-2 .tile-label,
.metric-tile.heatmap-2 .tile-sub { color: #fff !important; }
.metric-tile.heatmap-2 .tile-value { color: #fff !important; }
.metric-tile.heatmap-3 {
    background: #B8860B !important;
    border: none;
}
.metric-tile.heatmap-3 .tile-label,
.metric-tile.heatmap-3 .tile-sub { color: #fff !important; }
.metric-tile.heatmap-3 .tile-value { color: #fff !important; }
.metric-tile.heatmap-4 {
    background: #C2410C !important;
    border: none;
}
.metric-tile.heatmap-4 .tile-label,
.metric-tile.heatmap-4 .tile-sub { color: #fff !important; }
.metric-tile.heatmap-4 .tile-value { color: #fff !important; }
.metric-tile.heatmap-5 {
    background: #B91C1C !important;
    border: none;
}
.metric-tile.heatmap-5 .tile-label,
.metric-tile.heatmap-5 .tile-sub { color: #fff !important; }
.metric-tile.heatmap-5 .tile-value { color: #fff !important; }

/* ========== KEY FINDINGS ========== */
/* ========== PATHWAY PLANNING PANEL ========== */
.pathway-controls {
    display: flex;
    gap: 20px;
    align-items: flex-end;
    margin-bottom: 24px;
    flex-wrap: wrap;
}
.pathway-ctrl {
    flex: 1;
    min-width: 160px;
}
.pathway-ctrl label {
    display: block;
    font-size: 0.82rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 6px;
}
.pathway-ctrl select {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 0.88rem;
    background: #FFFFFF;
    color: var(--text-primary);
    min-height: 44px;
}
.pathway-metrics {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    margin-bottom: 20px;
}
.pathway-metric {
    background: #F3F4F8;
    border-radius: 10px;
    padding: 18px 16px;
    text-align: center;
}
.pathway-metric-warn {
    background: rgba(239,68,68,0.06);
    border: 1px solid rgba(239,68,68,0.15);
}
.pathway-metric-value {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', sans-serif;
    font-size: 1.8rem;
    font-weight: 700;
    color: var(--navy);
    line-height: 1.1;
}
.pathway-metric-warn .pathway-metric-value {
    color: #C75B4A;
}
.pathway-metric-label {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', sans-serif;
    font-size: 0.82rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-top: 6px;
    text-transform: uppercase;
    letter-spacing: 0.04em;
}
.pathway-metric-sub {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: 4px;
    line-height: 1.35;
}
@media (max-width: 768px) {
    .pathway-controls { flex-direction: column; gap: 14px; }
    .pathway-ctrl { min-width: auto; }
    .pathway-metrics { grid-template-columns: 1fr; gap: 12px; }
    .pathway-metric-value { font-size: 1.5rem; }
}

.key-findings {
    background: linear-gradient(135deg, rgba(245,158,11,0.06) 0%, rgba(239,68,68,0.04) 100%);
    border: 1px solid rgba(245,158,11,0.2);
    border-left: 4px solid #C75B4A;
    border-radius: 10px;
    padding: 24px 28px;
    margin: 20px 0;
}

.key-findings h4 {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-weight: 600;
    font-size: 1.07rem;
    text-transform: capitalize;
    letter-spacing: 0.06em;
    color: #DC2626;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.key-findings h4::before {
    content: '\2605';
    font-size: 0.9rem;
}

.key-findings p {
    font-size: 0.88rem;
    color: var(--text-primary);
    line-height: 1.6;
    margin-bottom: 6px;
}

.key-findings p:last-child {
    margin-bottom: 0;
}

.key-findings .kf-value {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-weight: 700;
    color: var(--navy);
}

.key-findings .kf-accent {
    color: var(--storage);
    font-weight: 600;
}

/* ========== NARRATIVE EMPHASIS ========== */
.narrative-panel {
    background: var(--bg-card);
    border: 1px solid var(--border-light);
    border-radius: 10px;
    padding: 24px 28px;
    margin-bottom: 20px;
}

.narrative-panel p {
    font-size: 0.88rem;
    color: var(--text-secondary);
    line-height: 1.65;
    margin-bottom: 10px;
}

.narrative-panel .em-blue {
    color: var(--clean-firm);
    font-weight: 600;
}

.narrative-panel .em-orange {
    color: var(--storage);
    font-weight: 600;
}

.narrative-panel .em-navy {
    color: var(--navy);
    font-weight: 700;
}

/* ========== LOADING / ERROR ========== */
.loading-overlay {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 70vh;
    gap: 20px;
}

.spinner {
    width: 48px;
    height: 48px;
    border: 4px solid var(--border);
    border-top-color: var(--navy);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideInLeft {
    from { opacity: 0; transform: translateX(-20px); }
    to { opacity: 1; transform: translateX(0); }
}

@keyframes scaleIn {
    from { opacity: 0; transform: scale(0.9); }
    to { opacity: 1; transform: scale(1); }
}

@keyframes countUp {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Apply animations to dashboard elements */
.metrics-row .metric-tile {
    animation: fadeInUp 0.5s cubic-bezier(0.34,1.56,0.64,1) both;
}
.metrics-row .metric-tile:nth-child(1) { animation-delay: 0.05s; }
.metrics-row .metric-tile:nth-child(2) { animation-delay: 0.1s; }
.metrics-row .metric-tile:nth-child(3) { animation-delay: 0.15s; }
.metrics-row .metric-tile:nth-child(4) { animation-delay: 0.2s; }
.metrics-row .metric-tile:nth-child(5) { animation-delay: 0.25s; }
.metrics-row .metric-tile:nth-child(6) { animation-delay: 0.3s; }

.key-findings {
    animation: slideInLeft 0.5s ease both;
    animation-delay: 0.3s;
}

.charts-row {
    animation: fadeInUp 0.6s ease both;
    animation-delay: 0.35s;
}

.peak-capacity-panel {
    animation: fadeInUp 0.5s ease both;
    animation-delay: 0.38s;
}

.cost-panel {
    animation: fadeInUp 0.5s ease both;
    animation-delay: 0.4s;
}

.scroll-transition {
    animation: fadeIn 0.8s ease both;
    animation-delay: 0.6s;
}

/* Smooth transitions when switching selections */
.tile-value, .dcl-value {
    transition: all 0.3s ease;
}

.loading-text {
    font-size: 1.02rem;
    color: var(--text-secondary);
}

.error-message {
    background: #FAF0DC;
    border: 1px solid #ffc107;
    border-radius: 10px;
    padding: 28px 32px;
    text-align: center;
    max-width: 600px;
    margin: 80px auto;
}

.error-message h2 {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-weight: 600;
    color: #856404;
    margin-bottom: 10px;
    font-size: 1.1rem;
}

.error-message p {
    color: #856404;
    font-size: 0.9rem;
}

.error-message code {
    background: rgba(0,0,0,0.06);
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.85rem;
}

/* ========== NARRATIVE STORY SECTIONS (grid_story-inspired) ========== */
#narrativeSection {
    background: #F3F4F8;
    border-radius: 16px;
    max-width: 1440px;
    margin: 24px auto 0;
    box-shadow: 0 4px 24px rgba(0,0,0,0.12);
    padding: 20px 0 40px;
}
.story-section {
    max-width: 900px;
    margin: 0 auto;
    padding: 72px 48px;
    opacity: 0;
    transform: translateY(40px);
    transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
}
.story-section.visible {
    opacity: 1;
    transform: translateY(0);
}
.cta-card:hover {
    transform: translateY(-4px) !important;
    box-shadow: 0 8px 28px rgba(0,0,0,0.15) !important;
}
.cta-card:active {
    transform: translateY(-1px) !important;
}
@media (prefers-reduced-motion: reduce) {
    .cta-card:hover { transform: none !important; }
}
.story-content {
    position: relative;
}
.story-badge {
    display: inline-block;
    padding: 5px 18px;
    border-radius: 9999px;
    font-size: 0.8rem;
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-weight: 700;
    letter-spacing: 1px;
    text-transform: capitalize;
    margin-bottom: 18px;
    background: rgba(26,39,68,0.1);
    color: #1A2744;
}
.story-badge-orange {
    background: rgba(239,68,68,0.1);
    color: #DC2626;
}
.story-badge-green {
    background: rgba(34,197,94,0.12);
    color: #7A8B5C;
}
.story-badge-red {
    background: rgba(239,68,68,0.12);
    color: #DC2626;
}
.story-section h2 {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 2.6rem;
    font-weight: 800;
    color: #DC2626;
    margin-bottom: 20px;
    letter-spacing: -0.5px;
    line-height: 1.2;
}
.story-lead {
    font-size: 1.05rem;
    color: #1A1A1A;
    line-height: 1.75;
    margin-bottom: 18px;
}
.story-section p {
    font-size: 0.98rem;
    color: #1A1A1A;
    line-height: 1.75;
    margin-bottom: 16px;
}
.story-stat-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
    gap: 20px;
    margin: 36px 0;
}
.story-stat-card {
    background: rgba(255,255,255,0.92);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(221,208,192,0.5);
    border-radius: 16px;
    padding: 32px 24px;
    text-align: center;
    box-shadow: 0 4px 6px -4px rgba(0,0,0,0.04);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.story-stat-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 15px -3px rgba(0,0,0,0.08), 0 4px 6px -4px rgba(0,0,0,0.04);
}
.story-stat-label {
    font-size: 0.85rem;
    font-weight: 700;
    color: #6B7280;
    letter-spacing: 0.8px;
    text-transform: capitalize;
    margin-bottom: 10px;
}
.story-stat-value {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 2.4rem;
    font-weight: 800;
    color: var(--navy);
    line-height: 1;
}
.story-stat-sub {
    font-size: 0.88rem;
    color: #6B7280;
    margin-top: 8px;
}
.story-insight-box {
    display: flex;
    gap: 16px;
    background: rgba(255,255,255,0.92);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(221,208,192,0.5);
    border-left: 4px solid #C75B4A;
    border-radius: 0 16px 16px 0;
    padding: 24px 28px;
    margin: 28px 0;
    font-size: 0.92rem;
    color: #1A1A1A;
    line-height: 1.7;
    box-shadow: 0 4px 6px -4px rgba(0,0,0,0.04);
}
.insight-icon {
    font-size: 1.4rem;
    flex-shrink: 0;
    margin-top: 2px;
}

/* Hero callout cards (narrative intro) */
.hero-callout-row {
    display: flex;
    gap: 24px;
    margin: 32px 0;
    flex-wrap: wrap;
}
.hero-callout-card {
    flex: 1;
    min-width: 140px;
    text-align: center;
    padding: 28px 16px;
    border-radius: 16px;
    background: linear-gradient(135deg, rgba(26,39,68,0.04) 0%, rgba(26,39,68,0.08) 100%);
    border: 1px solid rgba(26,39,68,0.1);
}
.hero-callout-card.hero-callout-green {
    background: linear-gradient(135deg, rgba(34,197,94,0.06) 0%, rgba(34,197,94,0.08) 100%);
    border-color: rgba(34,197,94,0.12);
}
.hero-callout-card.hero-callout-red {
    background: linear-gradient(135deg, rgba(239,68,68,0.06) 0%, rgba(245,158,11,0.08) 100%);
    border-color: rgba(239,68,68,0.12);
}
.hero-callout-value {
    font-size: 2.8rem;
    font-weight: 800;
    color: var(--navy);
    line-height: 1;
    letter-spacing: -1px;
}
.hero-callout-label {
    font-size: 0.8rem;
    color: #6B7280;
    margin-top: 6px;
    font-weight: 600;
    letter-spacing: 1px;
    text-transform: capitalize;
}
@media (max-width: 768px) {
    .hero-callout-row {
        gap: 12px;
    }
    .hero-callout-card {
        min-width: 100px;
        padding: 20px 10px;
    }
    .hero-callout-value {
        font-size: 2rem;
    }
    .hero-callout-label {
        font-size: 0.7rem;
    }
}
@media (max-width: 480px) {
    .hero-callout-row {
        gap: 8px;
    }
    .hero-callout-card {
        min-width: 80px;
        padding: 16px 8px;
        border-radius: 12px;
    }
    .hero-callout-value {
        font-size: 1.6rem;
    }
    .hero-callout-label {
        font-size: 0.75rem;
        letter-spacing: 0.5px;
    }
}

/* Energy spectrum accent bar */
.energy-spectrum-bar {
    height: 3px;
    background: linear-gradient(90deg, #1A2744 0%, #0EA5E9 15%, #22C55E 35%, #F59E0B 55%, #EF4444 80%, #DC2626 100%);
    border-radius: 2px;
    margin: 32px 0;
    opacity: 0.6;
}

/* ========== SCROLLYTELLING (grid_story-inspired) ========== */
.story-divider-wrap {
    max-width: 1400px;
    margin: 0 auto;
    padding: 0;
}
.story-divider {
    border: none;
    height: 3px;
    background: linear-gradient(90deg, #1A2744 0%, #0EA5E9 15%, #22C55E 35%, #F59E0B 55%, #EF4444 80%, #DC2626 100%);
    margin: 0;
    opacity: 0.7;
}

.scrolly-container {
    position: relative;
    display: flex;
    max-width: 1400px;
    margin: 0 auto;
}

.scrolly-sticky {
    position: sticky;
    top: 0;
    width: 55%;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 32px;
}

.scrolly-chart-wrap {
    background: rgba(255,255,255,0.92);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(221,208,192,0.5);
    border-radius: 16px;
    padding: 32px 28px;
    box-shadow: 0 10px 15px -3px rgba(0,0,0,0.08), 0 4px 6px -4px rgba(0,0,0,0.04);
    min-height: 430px;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.scrolly-chart-wrap canvas {
    width: 100% !important;
    max-height: 420px;
}

.scrolly-steps {
    width: 45%;
    position: relative;
    z-index: 2;
}

.scrolly-step {
    min-height: 85vh;
    display: flex;
    align-items: center;
    padding: 80px 48px 80px 40px;
    opacity: 0;
    transform: translateY(40px);
    transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
}

.scrolly-step:first-child {
    padding-top: 120px;
}

.scrolly-step:last-child {
    padding-bottom: 120px;
}

.scrolly-step.visible {
    opacity: 1;
    transform: translateY(0);
}

.scrolly-step.active .step-card {
    border-color: rgba(239,68,68,0.35);
    box-shadow: 0 10px 25px rgba(26,39,68,0.1), 0 4px 8px rgba(0,0,0,0.04);
    transform: translateY(-2px);
}

.step-card {
    background: rgba(255,255,255,0.92);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(221,208,192,0.5);
    border-radius: 16px;
    padding: 32px 32px;
    transition: border-color 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                box-shadow 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.step-card h3 {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 1.82rem;
    font-weight: 800;
    color: #DC2626;
    margin-bottom: 14px;
    line-height: 1.25;
    letter-spacing: -0.3px;
}

.step-card p {
    font-size: 0.95rem;
    color: #1A1A1A;
    line-height: 1.75;
    margin-bottom: 0;
}

.step-cost-callout {
    margin-top: 16px;
    padding: 12px 16px;
    border-radius: 12px;
    font-size: 0.92rem;
    color: #1A1A1A;
}
.step-cost-callout.step-cost-green {
    background: rgba(34,197,94,0.08);
    border: 1px solid rgba(34,197,94,0.15);
}
.step-cost-callout.step-cost-green strong {
    color: #7A8B5C;
}
.step-cost-callout.step-cost-red {
    background: rgba(239,68,68,0.08);
    border: 1px solid rgba(239,68,68,0.15);
}
.step-cost-callout.step-cost-red strong {
    color: #DC2626;
}
@media (max-width: 480px) {
    .step-cost-callout {
        padding: 10px 12px;
        font-size: 0.82rem;
        border-radius: 8px;
    }
}

/* Inline step charts: hidden on desktop, shown on mobile when sticky chart scrolls away */
.step-inline-chart {
    display: none;
}
@media (max-width: 1024px) {
    .step-inline-chart {
        display: block;
        width: 100%;
        height: 240px;
        margin-bottom: 18px;
        background: rgba(255,255,255,0.92);
        border: 1px solid rgba(221,208,192,0.5);
        border-radius: 12px;
        padding: 12px 8px;
    }
    .step-inline-chart canvas {
        width: 100% !important;
        height: 100% !important;
    }
    /* Hide the main sticky chart panel on mobile */
    .scrolly-sticky {
        display: none;
    }
}
@media (max-width: 480px) {
    .step-inline-chart {
        height: 200px;
        padding: 8px 4px;
        margin-bottom: 14px;
    }
}

/* Responsive scrollytelling */
@media (max-width: 1024px) {
    .scrolly-container {
        flex-direction: column;
    }
    .scrolly-sticky {
        width: 100%;
        height: 50vh;
        position: relative;
        top: auto;
        padding: 24px 20px;
    }
    .scrolly-steps {
        width: 100%;
    }
    .scrolly-step {
        min-height: auto;
        padding: 48px 24px;
    }
}
/* Mobile scrollytelling: re-enable sticky behavior in stacked layout */
@media (max-width: 1024px) and (min-width: 481px) {
    .scrolly-sticky {
        position: sticky;
        top: 0;
        z-index: 10;
        height: 45vh;
    }
}

/* ========== INLINE VISUALIZATIONS ========== */
.curtailment-visual {
    display: flex;
    gap: 16px;
    margin: 32px 0;
    flex-wrap: wrap;
    max-width: 680px;
    margin-left: auto;
    margin-right: auto;
}
.curtail-bar-group {
    flex: 1;
    min-width: 120px;
    text-align: center;
}
.curtail-bar-label {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 0.92rem;
    font-weight: 600;
    color: var(--text-muted);
    margin-bottom: 8px;
}
.curtail-bar-stack {
    height: 180px;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    background: rgba(243,244,248,0.6);
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border-light);
}
.curtail-bar-fill {
    transition: height 0.6s cubic-bezier(0.34,1.56,0.64,1);
    border-radius: 0;
}
.curtail-bar-value {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 0.9rem;
    font-weight: 700;
    color: var(--navy);
    margin-top: 6px;
}
.curtail-bar-sub {
    font-size: 0.72rem;
    color: var(--text-muted);
}
.curtail-legend {
    display: flex;
    justify-content: center;
    gap: 24px;
    margin-bottom: 8px;
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', sans-serif;
    font-size: 0.82rem;
    font-weight: 600;
    color: var(--text-secondary);
}
.curtail-legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
}
.curtail-legend-swatch {
    display: inline-block;
    width: 14px;
    height: 14px;
    border-radius: 3px;
}

.reliability-gauge-row {
    display: flex;
    gap: 20px;
    margin: 32px 0;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 780px;
    margin-left: auto;
    margin-right: auto;
}
.reliability-gauge {
    flex: 1;
    min-width: 130px;
    max-width: 200px;
    text-align: center;
    padding: 24px 16px;
    background: rgba(255,255,255,0.92);
    border: 1px solid rgba(221,208,192,0.5);
    border-radius: 14px;
}
.gauge-ring {
    width: 110px;
    height: 110px;
    margin: 0 auto 10px;
    position: relative;
}
.gauge-ring svg {
    transform: rotate(-90deg);
}
.gauge-ring-label {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--navy);
}
.gauge-name {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--text-muted);
    letter-spacing: 0.04em;
}

/* Section illustration container */
.section-illustration {
    display: flex;
    justify-content: center;
    margin: 32px 0;
}
.section-illustration svg {
    width: 100%;
    max-width: 680px;
    height: auto;
}
/* Trilemma figure */
.trilemma-svg {
    max-width: 420px !important;
}

/* Region toggle pills */
/* Clean firm cost indicator */
.cf-cost-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(245,158,11,0.08);
    border: 1.5px solid rgba(245,158,11,0.35);
    border-radius: 10px;
    padding: 10px 18px;
    margin: -8px 0 16px;
    font-size: 0.85rem;
    color: #92400E;
    line-height: 1.5;
}
.cf-indicator-icon {
    font-size: 1.1rem;
    flex-shrink: 0;
}
.cf-cost-indicator strong {
    font-weight: 700;
}

/* Region toggle pills */
.region-toggle-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
    margin: 16px 0 8px;
}
.region-toggle-btn {
    display: inline-flex;
    align-items: center;
    padding: 8px 18px;
    min-height: 44px;
    border-radius: 9999px;
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', sans-serif;
    font-size: 0.82rem;
    font-weight: 700;
    letter-spacing: 0.6px;
    cursor: pointer;
    border: 2px solid #D4D8E0;
    background: rgba(255,255,255,0.7);
    color: #374151;
    transition: all 0.2s;
    text-transform: uppercase;
}
.region-toggle-btn:hover {
    border-color: #0EA5E9;
    color: #0284C7;
    background: rgba(14,165,233,0.06);
}
.region-toggle-btn.active {
    border-color: #1A2744;
    background: #1A2744;
    color: #fff;
}

/* Incremental mix section */
.incremental-mix-wrap {
    margin: 24px 0;
}
.incremental-chart-container {
    min-height: 320px;
    position: relative;
}
.incremental-region-pills {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
    margin: 16px 0 12px;
}
.incremental-pill {
    display: inline-block;
    padding: 5px 16px;
    border-radius: 9999px;
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', sans-serif;
    font-size: 0.78rem;
    font-weight: 700;
    letter-spacing: 0.6px;
    cursor: pointer;
    border: 2px solid #D4D8E0;
    background: rgba(255,255,255,0.7);
    color: #374151;
    transition: all 0.2s;
    text-transform: uppercase;
}
.incremental-pill:hover {
    border-color: #0EA5E9;
    color: #0284C7;
}
.incremental-pill.active {
    border-color: #1A2744;
    background: #1A2744;
    color: #fff;
}
.incremental-insight {
    margin-top: 16px;
    padding: 14px 20px;
    background: rgba(26,39,68,0.04);
    border-left: 4px solid #1A2744;
    border-radius: 0 10px 10px 0;
    font-size: 0.9rem;
    color: #374151;
    line-height: 1.65;
    transition: opacity 0.3s;
}
.incremental-insight strong {
    color: #1A2744;
}

/* Transition fuel visual */
.transition-fuel-row {
    display: flex;
    gap: 24px;
    margin: 32px 0;
    flex-wrap: wrap;
    max-width: 680px;
    margin-left: auto;
    margin-right: auto;
}
.transition-fuel-card {
    flex: 1;
    min-width: min(220px, 100%);
    background: rgba(255,255,255,0.92);
    border: 1px solid rgba(221,208,192,0.5);
    border-radius: 14px;
    padding: 24px 20px;
    text-align: center;
}
.transition-fuel-icon {
    margin-bottom: 12px;
}
.transition-fuel-title {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--navy);
    margin-bottom: 8px;
}
.transition-fuel-desc {
    font-size: 0.88rem;
    color: var(--text-secondary);
    line-height: 1.6;
}
.transition-fuel-stat {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 1.5rem;
    font-weight: 800;
    margin-top: 10px;
    line-height: 1;
}

@media (max-width: 768px) {
    .curtailment-visual {
        gap: 8px;
    }
    .curtail-bar-group {
        min-width: 50px;
    }
    .curtail-bar-stack {
        height: 90px;
    }
    .curtail-bar-label {
        font-size: 0.72rem;
    }
    .curtail-bar-value {
        font-size: 0.78rem;
    }
    .reliability-gauge-row {
        gap: 10px;
    }
    .reliability-gauge {
        min-width: 80px;
        padding: 14px 8px;
    }
    .gauge-ring {
        width: 70px;
        height: 70px;
    }
    .gauge-ring svg {
        width: 70px;
        height: 70px;
    }
    .gauge-ring-label {
        font-size: 0.95rem;
    }
    .transition-fuel-row {
        flex-direction: column;
        gap: 14px;
    }
    .transition-fuel-card {
        min-width: unset;
        padding: 18px 14px;
    }
    .transition-fuel-stat {
        font-size: 1.3rem;
    }
    .section-illustration {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        margin: 18px -10px;
        padding: 0 10px;
    }
    .section-illustration svg {
        min-width: min(340px, 100%);
    }
    .trilemma-svg {
        max-width: 300px !important;
        min-width: min(260px, 100%) !important;
    }
    .region-toggle-row, .incremental-region-pills {
        gap: 6px;
    }
    .region-toggle-btn, .incremental-pill {
        padding: 5px 12px;
        font-size: 0.75rem;
    }
    .incremental-chart-container {
        min-height: 260px;
    }
}

@media (max-width: 480px) {
    .curtailment-visual {
        gap: 5px;
    }
    .curtail-bar-group {
        min-width: 42px;
    }
    .curtail-bar-stack {
        height: 70px;
    }
    .curtail-bar-label {
        font-size: 0.75rem;
    }
    .curtail-bar-value {
        font-size: 0.75rem;
    }
    .curtail-bar-sub {
        font-size: 0.6rem;
    }
    .reliability-gauge-row {
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
    }
    .reliability-gauge {
        min-width: 70px;
        max-width: 80px;
        padding: 10px 6px;
    }
    .gauge-ring {
        width: 56px;
        height: 56px;
    }
    .gauge-ring svg {
        width: 56px;
        height: 56px;
    }
    .gauge-ring-label {
        font-size: 0.82rem;
    }
    .gauge-name {
        font-size: 0.75rem;
    }
    .transition-fuel-card {
        padding: 14px 12px;
    }
    .transition-fuel-title {
        font-size: 0.95rem;
    }
    .transition-fuel-desc {
        font-size: 0.82rem;
    }
    .transition-fuel-stat {
        font-size: 1.15rem;
    }
    .section-illustration svg {
        min-width: 340px;
    }
    .trilemma-svg {
        max-width: 260px !important;
        min-width: 220px !important;
    }
    .region-toggle-row, .incremental-region-pills {
        gap: 4px;
    }
    .region-toggle-btn, .incremental-pill {
        padding: 8px 12px;
        font-size: 0.75rem;
        min-height: 44px;
    }
    .incremental-chart-container {
        min-height: 280px;
    }
    .incremental-insight {
        font-size: 0.82rem;
        padding: 10px 14px;
    }
}

/* ========== CONCLUSION PANEL ========== */
.conclusion-panel {
    background: linear-gradient(135deg, #1A2744 0%, #2D3F5E 100%);
    border-radius: 20px;
    padding: 48px 40px;
    margin: 48px 0 32px;
    color: #fff;
    position: relative;
    overflow: hidden;
}
.conclusion-panel::before {
    content: '';
    position: absolute;
    top: -60px;
    right: -60px;
    width: 200px;
    height: 200px;
    background: radial-gradient(circle, rgba(34,197,94,0.15) 0%, transparent 70%);
    border-radius: 50%;
}
.conclusion-panel::after {
    content: '';
    position: absolute;
    bottom: -40px;
    left: -40px;
    width: 160px;
    height: 160px;
    background: radial-gradient(circle, rgba(14,165,233,0.12) 0%, transparent 70%);
    border-radius: 50%;
}
.conclusion-panel h2 {
    font-family: 'Franklin Gothic Demi', 'Lexend', 'Plus Jakarta Sans', sans-serif;
    font-size: 2rem;
    font-weight: 700;
    color: #fff;
    margin: 0 0 8px;
    line-height: 1.2;
    position: relative;
    z-index: 1;
}
.conclusion-panel .conclusion-subtitle {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', sans-serif;
    font-size: 1.1rem;
    font-weight: 400;
    color: rgba(255,255,255,0.7);
    margin-bottom: 28px;
    position: relative;
    z-index: 1;
}
.conclusion-panel p {
    color: rgba(255,255,255,0.88);
    line-height: 1.7;
    position: relative;
    z-index: 1;
}
.conclusion-panel strong {
    color: #fff;
}
.conclusion-pillars {
    display: flex;
    gap: 20px;
    margin: 32px 0;
    flex-wrap: wrap;
    position: relative;
    z-index: 1;
}
.conclusion-pillar {
    flex: 1;
    min-width: 200px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 14px;
    padding: 24px 20px;
    backdrop-filter: blur(10px);
}
.conclusion-pillar-icon {
    width: 48px;
    height: 48px;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 14px;
    font-size: 1.5rem;
}
.conclusion-pillar h4 {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', sans-serif;
    font-size: 1.05rem;
    font-weight: 700;
    color: #fff;
    margin: 0 0 8px;
}
.conclusion-pillar p {
    font-size: 0.88rem;
    color: rgba(255,255,255,0.72);
    margin: 0;
    line-height: 1.5;
}
.conclusion-warning {
    background: rgba(239,68,68,0.12);
    border: 1px solid rgba(239,68,68,0.25);
    border-radius: 12px;
    padding: 20px 24px;
    margin: 28px 0;
    position: relative;
    z-index: 1;
}
.conclusion-warning strong {
    color: #FCA5A5;
}
.conclusion-warning p {
    color: rgba(255,255,255,0.82);
    margin: 0;
    font-size: 0.95rem;
}
.conclusion-bottom-line {
    font-family: 'Franklin Gothic Demi', 'Lexend', 'Plus Jakarta Sans', sans-serif;
    font-size: 1.25rem;
    font-weight: 600;
    color: #22C55E;
    text-align: center;
    margin-top: 28px;
    padding-top: 20px;
    border-top: 1px solid rgba(255,255,255,0.1);
    position: relative;
    z-index: 1;
}
@media (max-width: 768px) {
    .conclusion-panel {
        padding: 32px 24px;
        margin: 32px 0 24px;
    }
    .conclusion-panel h2 {
        font-size: 1.6rem;
    }
    .conclusion-pillars {
        flex-direction: column;
        gap: 14px;
    }
    .conclusion-pillar {
        min-width: unset;
        padding: 18px 16px;
    }
    .conclusion-bottom-line {
        font-size: 1.05rem;
    }
}
@media (max-width: 480px) {
    .conclusion-panel {
        padding: 24px 18px;
        border-radius: 14px;
    }
    .conclusion-panel h2 {
        font-size: 1.25rem;
    }
    .conclusion-panel .conclusion-subtitle {
        font-size: 0.9rem;
    }
    .conclusion-panel p {
        font-size: 0.88rem;
    }
    .conclusion-warning {
        padding: 16px 14px;
    }
    .conclusion-warning p {
        font-size: 0.85rem;
    }
    .conclusion-pillar h4 {
        font-size: 0.95rem;
    }
    .conclusion-pillar p {
        font-size: 0.82rem;
    }
    .conclusion-bottom-line {
        font-size: 0.95rem;
    }
}

/* ========== HERO TAKEAWAY BANNER ========== */
.hero-takeaway {
    background: linear-gradient(135deg, #F8F6F3 0%, #EFF6EF 60%, #F0F4F8 100%);
    border-radius: 18px;
    padding: 40px 36px;
    margin: 24px auto 32px;
    max-width: 900px;
    text-align: center;
    position: relative;
    overflow: hidden;
    border: 1px solid rgba(30,58,95,0.12);
    box-shadow: 0 4px 20px rgba(0,0,0,0.06);
}
.hero-takeaway::before {
    content: '';
    position: absolute;
    top: -80px; left: 50%; transform: translateX(-50%);
    width: 300px; height: 300px;
    background: radial-gradient(circle, rgba(34,197,94,0.06) 0%, transparent 70%);
}
.hero-takeaway-icon {
    width: 56px; height: 56px;
    margin: 0 auto 14px;
    display: flex; align-items: center; justify-content: center;
    background: rgba(30,58,95,0.08);
    border-radius: 50%;
    border: 2px solid rgba(30,58,95,0.15);
    position: relative; z-index: 1;
}
.hero-takeaway-headline {
    font-family: 'Franklin Gothic Demi', 'Lexend', 'Plus Jakarta Sans', sans-serif;
    font-size: 1.55rem;
    font-weight: 700;
    color: var(--navy);
    line-height: 1.25;
    margin-bottom: 14px;
    position: relative; z-index: 1;
}
.hero-takeaway-headline em {
    font-style: normal;
    color: #16A34A;
}
.hero-takeaway-sub {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', sans-serif;
    font-size: 1.02rem;
    color: #4B5563;
    line-height: 1.65;
    max-width: 680px;
    margin: 0 auto;
    position: relative; z-index: 1;
}
.hero-takeaway-sub strong {
    color: var(--navy);
}
@media (max-width: 768px) {
    .hero-takeaway { padding: 28px 22px; margin: 18px auto 24px; }
    .hero-takeaway-headline { font-size: 1.25rem; }
    .hero-takeaway-sub { font-size: 0.95rem; }
    .hero-takeaway-icon { width: 48px; height: 48px; }
}
@media (max-width: 480px) {
    .hero-takeaway { padding: 24px 16px; border-radius: 14px; margin: 14px auto 20px; }
    .hero-takeaway-headline { font-size: 1.1rem; }
    .hero-takeaway-sub { font-size: 0.88rem; }
}

/* ========== SITE INTRO (before hero) ========== */
.site-intro {
    max-width: 1000px;
    margin: 0 auto;
    padding: 44px 36px 36px;
    text-align: center;
    color: rgba(255,255,255,0.92);
}
.site-intro-title {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 1.7rem;
    font-weight: 700;
    color: #FFFFFF;
    margin-bottom: 16px;
    letter-spacing: 0.02em;
}
.site-intro-text {
    font-size: 0.98rem;
    color: rgba(255,255,255,0.78);
    line-height: 1.8;
    max-width: 800px;
    margin: 0 auto 24px;
}
.site-intro-text strong {
    color: rgba(255,255,255,0.95);
    font-weight: 600;
}
.site-intro-actions {
    display: flex;
    justify-content: center;
    gap: 16px;
    flex-wrap: wrap;
}
.pdf-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: rgba(255,255,255,0.12);
    border: 1px solid rgba(255,255,255,0.25);
    color: #FFFFFF;
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', sans-serif;
    font-weight: 600;
    font-size: 0.88rem;
    padding: 10px 22px;
    border-radius: 8px;
    text-decoration: none;
    transition: all 0.2s;
    letter-spacing: 0.02em;
    cursor: pointer;
}
.pdf-btn:hover {
    background: rgba(239,68,68,0.85);
    border-color: rgba(239,68,68,0.9);
    transform: translateY(-1px);
    box-shadow: 0 4px 16px rgba(239,68,68,0.3);
}
.pdf-btn svg { flex-shrink: 0; }
.paper-link-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: rgba(14,165,233,0.15);
    border: 1px solid rgba(14,165,233,0.35);
    color: #FFFFFF;
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', sans-serif;
    font-weight: 600;
    font-size: 0.88rem;
    padding: 10px 22px;
    border-radius: 8px;
    text-decoration: none;
    transition: all 0.2s;
    letter-spacing: 0.02em;
}
.paper-link-btn:hover {
    background: rgba(14,165,233,0.35);
    border-color: rgba(14,165,233,0.55);
    transform: translateY(-1px);
}

/* ========== DASHBOARD INTRO ========== */
.dashboard-intro {
    max-width: 900px;
    margin: 0 auto 8px;
    padding: 28px 32px 24px;
    text-align: center;
}
.dashboard-intro-title {
    font-family: 'Franklin Gothic Demi', 'Barlow Semi Condensed', 'Arial Narrow', 'Helvetica Neue', Arial, sans-serif;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--navy);
    margin-bottom: 10px;
    letter-spacing: 0.02em;
}
.dashboard-intro-text {
    font-size: 0.95rem;
    color: var(--text-secondary);
    line-height: 1.7;
    max-width: 760px;
    margin: 0 auto;
}
.dashboard-intro-text strong {
    color: var(--navy);
    font-weight: 600;
}
@media (max-width: 768px) {
    .site-intro { padding: 32px 20px 28px; }
    .site-intro-title { font-size: 1.35rem; }
    .site-intro-text { font-size: 0.9rem; }
    .dashboard-intro { padding: 22px 18px 18px; }
    .dashboard-intro-title { font-size: 1.25rem; }
    .dashboard-intro-text { font-size: 0.9rem; }
}
@media (max-width: 480px) {
    .site-intro { padding: 24px 14px 20px; }
    .site-intro-title { font-size: 1.2rem; }
    .site-intro-text { font-size: 0.85rem; }
    .site-intro-actions { flex-direction: column; align-items: center; }
    .dashboard-intro { padding: 18px 14px 14px; }
    .dashboard-intro-title { font-size: 1.1rem; }
    .dashboard-intro-text { font-size: 0.85rem; }
}

/* ========== FOOTER ========== */
.footer {
    text-align: center;
    padding: 20px 40px;
    font-size: 0.82rem;
    color: rgba(255,255,255,0.5);
    border-top: none;
}

/* ========== RESPONSIVE ========== */
@media (max-width: 1100px) {
    .charts-row {
        grid-template-columns: 1fr !important;
    }
}
@media (max-width: 1000px) {
    .metrics-row {
        grid-template-columns: repeat(3, 1fr);
    }
}
@media (max-width: 860px) {
    .metrics-row {
        grid-template-columns: repeat(2, 1fr);
    }
}

@media (max-width: 768px) {
    html {
        font-size: 15px;
    }
    .main-content {
        padding: 20px 14px 40px;
    }
    .header {
        padding: 52px 16px 44px;
    }
    .header h1 {
        font-size: 2.0rem;
        letter-spacing: 0.3px;
    }
    .header .subtitle {
        font-size: 1.0rem;
        line-height: 1.45;
    }
    .header .data-year-label {
        font-size: 0.75rem;
    }
    .header-logo {
        height: 28px;
        top: 14px;
        left: 16px;
    }
    .metrics-row {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
    }
    .metric-tile {
        padding: 16px 12px;
    }
    .metric-tile .tile-value {
        font-size: 1.8rem;
    }
    .metric-tile .tile-label {
        font-size: 0.75rem;
    }
    .metric-tile .tile-sub {
        font-size: 0.75rem;
    }
    .metric-tile:hover {
        transform: none;
    }
    .controls-row {
        flex-direction: column;
        align-items: stretch;
        gap: 14px;
    }
    .control-group select {
        min-width: 100%;
        padding: 13px 38px 13px 16px;
        font-size: 1rem;
    }
    .region-context {
        margin-left: 0;
        gap: 16px;
        flex-wrap: wrap;
    }
    .cf-cost-indicator {
        font-size: 0.8rem;
        padding: 8px 14px;
    }
    .key-findings {
        padding: 18px 16px;
    }
    .key-findings h4 {
        font-size: 0.95rem;
    }
    .key-findings p {
        font-size: 0.84rem;
    }
    .chart-panel {
        padding: 18px 14px;
    }
    .chart-panel h3 {
        font-size: 1.1rem;
        margin-bottom: 12px;
    }
    .donut-container {
        max-width: 200px;
    }
    .donut-center-label .dcl-value {
        font-size: 1.6rem;
    }
    .donut-legend {
        gap: 4px 10px;
        font-size: 0.75rem;
        margin-top: 12px;
    }
    .donut-legend-swatch {
        width: 10px;
        height: 10px;
    }
    .compressed-day-container {
        height: 420px;
    }
    .peak-tower-wrap {
        height: 240px;
        gap: 16px;
        padding-top: 16px;
    }
    .peak-tower {
        max-width: 80px;
    }
    .peak-tower-value {
        font-size: 0.8rem;
    }
    .peak-tower-label {
        font-size: 0.72rem;
    }
    .peak-capacity-panel,
    .cost-panel {
        padding: 18px 14px;
    }
    .peak-capacity-note {
        font-size: 0.82rem;
    }
    .cost-table {
        font-size: 0.82rem;
    }
    .cost-table th {
        padding: 8px 8px;
        font-size: 0.8rem;
    }
    .cost-table td {
        padding: 8px 8px;
    }
    .scroll-transition-inner {
        padding: 28px 20px;
    }
    .scroll-transition-text {
        font-size: 1.15rem;
    }
    .footer {
        padding: 16px 14px;
        font-size: 0.75rem;
    }
    /* Narrative story sections on mobile */
    .story-section {
        padding: 48px 18px;
    }
    .story-section h2 {
        font-size: 1.8rem;
        letter-spacing: -0.3px;
    }
    .story-lead {
        font-size: 0.95rem;
    }
    .story-section p {
        font-size: 0.9rem;
    }
    .story-stat-row {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
    }
    .story-stat-card {
        padding: 16px 12px;
    }
    .story-stat-value {
        font-size: 1.5rem;
    }
    .story-stat-label {
        font-size: 0.75rem;
    }
    .story-insight-box {
        padding: 18px 16px;
        font-size: 0.85rem;
        gap: 12px;
        flex-direction: column;
    }
    .step-card {
        padding: 22px 18px;
    }
    .step-card h3 {
        font-size: 1.4rem;
    }
    .step-card p {
        font-size: 0.88rem;
    }
    .scrolly-chart-wrap {
        padding: 18px 14px;
        min-height: 280px;
    }
    .scrolly-chart-wrap canvas {
        max-height: 300px;
    }
    .target-mode-panel {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
        padding: 14px 16px;
    }
    .target-mode-toggle button {
        padding: 10px 16px;
        font-size: 0.82rem;
    }
    .target-mode-info {
        font-size: 0.78rem;
    }
}

/* Small phone (480px and below) */
@media (max-width: 480px) {
    html {
        font-size: 14px;
    }
    .main-content {
        padding: 14px 10px 32px;
    }
    .header {
        padding: 36px 12px 28px;
    }
    .header h1 {
        font-size: 1.6rem;
        letter-spacing: 0;
    }
    .header .subtitle {
        font-size: 0.9rem;
    }
    .metrics-row {
        grid-template-columns: 1fr 1fr;
        gap: 8px;
    }
    .metric-tile {
        padding: 14px 10px;
    }
    .metric-tile .tile-value {
        font-size: 1.55rem;
    }
    .metric-tile .tile-label {
        font-size: 0.75rem;
        margin-bottom: 5px;
    }
    .metric-tile .tile-sub {
        font-size: 0.75rem;
    }
    .chart-panel {
        padding: 14px 10px;
    }
    .chart-panel h3 {
        font-size: 1rem;
    }
    .donut-container {
        max-width: 170px;
    }
    .donut-center-label .dcl-value {
        font-size: 1.35rem;
    }
    .donut-legend {
        gap: 3px 8px;
        font-size: 0.72rem;
        margin-top: 10px;
    }
    .donut-legend-swatch {
        width: 9px;
        height: 9px;
    }
    .compressed-day-container {
        height: 380px;
    }
    .peak-tower-wrap {
        height: 200px;
        gap: 10px;
    }
    .peak-tower {
        max-width: 65px;
    }
    .cost-table {
        font-size: 0.75rem;
    }
    .cost-table th {
        padding: 6px 5px;
        font-size: 0.73rem;
    }
    .cost-table td {
        padding: 6px 5px;
    }
    .cost-table .resource-dot {
        width: 9px;
        height: 9px;
        margin-right: 4px;
    }
    .story-section {
        padding: 36px 12px;
    }
    .story-section h2 {
        font-size: 1.5rem;
    }
    .story-stat-row {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
    }
    .story-stat-card {
        padding: 12px 8px;
    }
    .story-stat-value {
        font-size: 1.3rem;
    }
    .story-insight-box {
        padding: 14px 12px;
        font-size: 0.82rem;
    }
    /* Scrollytelling on small phones */
    .scrolly-sticky {
        height: 40vh;
        padding: 14px 10px;
    }
    .scrolly-chart-wrap {
        padding: 12px 8px;
        min-height: 220px;
        border-radius: 12px;
    }
    .scrolly-chart-wrap canvas {
        max-height: 240px;
    }
    .scrolly-step {
        padding: 28px 12px;
    }
    .step-card {
        padding: 18px 14px;
        border-radius: 12px;
    }
    .step-card h3 {
        font-size: 1.2rem;
        margin-bottom: 10px;
    }
    .step-card p {
        font-size: 0.84rem;
        line-height: 1.65;
    }
    .scroll-transition {
        padding: 40px 0 28px;
    }
    .scroll-transition-inner {
        padding: 22px 16px;
        border-radius: 12px;
    }
    .scroll-transition-text {
        font-size: 1rem;
    }
    .footer {
        font-size: 0.75rem;
        padding: 12px 10px;
    }
}

/* ========== 375px BREAKPOINT (mid-range phones) ========== */
@media (max-width: 375px) {
    .header { padding: 28px 12px 24px; }
    .header h1 { font-size: 1.6rem; }
    .header .subtitle { font-size: 0.85rem; }
    .main-content { padding: 10px 8px 24px; }
    .story-section { padding: 32px 14px; }
    .hero-callout-card { min-width: 70px; padding: 12px 6px; }
    .hero-callout-value { font-size: 1.4rem; }
    .scrolly-chart-wrap { min-height: 250px; }
    /* Dashboard controls */
    .control-group select { min-width: 100%; font-size: 0.82rem; }
    .sensitivity-toggles-grid { gap: 10px 16px; }
    .toggle-btn-group button { padding: 5px 8px; font-size: 0.72rem; min-width: 38px; }
    /* Charts */
    .donut-container { max-width: 150px; }
    .donut-center-label .dcl-value { font-size: 1.2rem; }
    .donut-legend { gap: 2px 6px; font-size: 0.68rem; }
    .compressed-day-container { height: 340px; }
    /* Cost table */
    .cost-table { font-size: 0.7rem; }
    .cost-table th { padding: 5px 3px; font-size: 0.68rem; }
    .cost-table td { padding: 5px 3px; }
    .cost-table .resource-dot { width: 8px; height: 8px; margin-right: 3px; }
    /* Metrics */
    .metrics-row { grid-template-columns: 1fr; gap: 6px; }
    .metric-tile .tile-value { font-size: 1.3rem; }
}

/* Touch-friendly tap targets */
@media (hover: none) and (pointer: coarse) {
    .control-group select {
        min-height: 48px;
        font-size: 16px; /* prevent iOS zoom on focus */
    }
    .metric-tile:hover {
        transform: none;
        box-shadow: none;
    }
    .story-stat-card:hover {
        transform: none;
        box-shadow: 0 4px 6px -4px rgba(0,0,0,0.04);
    }
}

/* Landscape phones */
@media (max-height: 500px) and (orientation: landscape) {
    .scrolly-sticky {
        height: 70vh;
    }
    .scrolly-chart-wrap {
        min-height: 200px;
    }
    .scrolly-chart-wrap canvas {
        max-height: 200px;
    }
}
</style>
</head>
<body>

<!-- TOP NAVIGATION BAR -->
<nav class="top-nav" id="topNav">
    <span class="nav-brand">The 8,760 Problem</span>
    <button class="nav-hamburger" id="navHamburger" aria-label="Toggle navigation menu">
        <svg viewBox="0 0 24 24"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
    </button>
    <div class="top-nav-inner" id="navLinks">
        <a href="index.html">Home</a>
        <a href="dashboard.html" class="nav-active">Cost Optimizer</a>
        <a href="abatement_dashboard.html">Abatement Dashboard</a>
        <a href="region_deepdive.html">Regional Deep Dives</a>
        <a href="abatement_comparison.html">CO&#8322; Abatement Summary</a>
        <a href="eac_scarcity.html">EAC Scarcity</a>
        <a href="research_paper.html">Methodology &amp; Paper</a>
        <a href="about.html">About</a>
        <a href="../power-gen-decarbonization/site/index.html">Generator Analysis</a>
        <a href="about.html">About</a>
    </div>
</nav>
<div style="background:#F3F4F8;padding:8px 24px;"><a href="index.html" class="back-link" style="font-family:'Franklin Gothic Demi','Barlow Semi Condensed',sans-serif;font-size:0.82rem;font-weight:600;color:#1A2744;text-decoration:none;display:inline-flex;align-items:center;gap:6px;letter-spacing:0.03em;min-height:44px;"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"/></svg>Back to Home</a></div>

<!-- HEADER / BANNER -->
<header class="header">
    <h1>The 8,760 Problem</h1>
    <p class="subtitle">Optimizing clean energy procurement across 8,760 hours, five power markets, and hundreds of cost scenarios.</p>
    <div class="header-accent"></div>
</header>
<div class="bottom-banner"></div>

<!-- PAGE TITLE & INTRO -->
<div class="site-intro">
    <h2 class="site-intro-title">Cost Optimizer Dashboard</h2>
    <p class="site-intro-text">
        This interactive dashboard models the cost of matching clean energy supply to electricity demand
        on an <strong>hourly basis</strong> across five major U.S. grid regions. Use the sensitivity controls
        below to explore how changes in renewable, storage, and firm generation costs reshape the optimal
        procurement portfolio at every matching threshold from 75% to 100%. The optimizer co-optimizes
        resource mix and cost simultaneously &mdash; different cost assumptions produce fundamentally different
        optimal strategies.
    </p>
</div>

<!-- LOADING STATE -->
<div class="main-content" id="loadingState">
    <div class="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Loading analysis results&hellip;</div>
    </div>
</div>

<!-- ERROR STATE (hidden) -->
<div class="main-content" id="errorState" style="display:none;"></div>

<!-- DASHBOARD (hidden until data loads) -->
<div class="main-content" id="dashboardContent" style="display:none;">

    <!-- DASHBOARD INTRO -->
    <div class="dashboard-intro">
        <h2 class="dashboard-intro-title">Interactive Cost &amp; Matching Explorer</h2>
        <p class="dashboard-intro-text">
            Use the controls below to explore how clean energy procurement costs and resource mixes change
            across five major U.S. power markets. Select a <strong>region</strong> to see its unique grid profile,
            then adjust the <strong>hourly match target</strong> to compare portfolios from 75% to 100% matching.
            The dashboard updates in real time &mdash; showing the optimal resource mix, cost breakdown,
            peak capacity needs, and curtailment for each scenario. Scroll past the dashboard to read the
            full narrative analysis.
        </p>
    </div>

    <!-- CONTROLS -->
    <div class="controls-row">
        <div class="control-group">
            <label for="regionSelect">Region / ISO</label>
            <select id="regionSelect"></select>
        </div>
        <div class="control-group">
            <label for="thresholdSelect">Interim Target <span class="info-icon-wrapper" tabindex="0"><span class="info-icon" aria-label="Info">i</span><span class="info-tooltip">Your near-term hourly clean energy procurement target. This drives today's resource procurement decisions. Set this to what you plan to achieve in the next 3-5 years.</span></span></label>
            <select id="thresholdSelect"></select>
        </div>
        <div class="control-group">
            <label for="longtermTarget">Long-term Target <span class="info-icon-wrapper" tabindex="0"><span class="info-icon" aria-label="Info">i</span><span class="info-tooltip">Your ultimate hourly clean energy goal (must be &ge; interim target). Used to calculate how much of today's interim procurement remains useful at the end state &mdash; and how much becomes redundant if the optimal resource mix shifts.</span></span></label>
            <select id="longtermTarget">
                <option value="">Same as Interim</option>
            </select>
        </div>
        <div class="control-group">
            <label for="interimYear">Interim Year</label>
            <select id="interimYear">
                <option value="2027">2027</option>
                <option value="2028">2028</option>
                <option value="2029">2029</option>
                <option value="2030">2030</option>
                <option value="2031">2031</option>
                <option value="2032" selected>2032</option>
                <option value="2033">2033</option>
                <option value="2034">2034</option>
                <option value="2035">2035</option>
            </select>
        </div>
        <div class="control-group">
            <label for="longtermYear">Long-term Year</label>
            <select id="longtermYear">
                <option value="2036">2036</option>
                <option value="2037">2037</option>
                <option value="2038">2038</option>
                <option value="2039">2039</option>
                <option value="2040">2040</option>
                <option value="2041">2041</option>
                <option value="2042">2042</option>
                <option value="2043">2043</option>
                <option value="2044">2044</option>
                <option value="2045" selected>2045</option>
                <option value="2046">2046</option>
                <option value="2047">2047</option>
                <option value="2048">2048</option>
                <option value="2049">2049</option>
                <option value="2050">2050</option>
            </select>
        </div>
        <!-- Legacy cfCostSelect hidden for backward compat -->
        <div class="control-group" style="display:none;">
            <label for="cfCostSelect">Clean Firm Cost Assumption</label>
            <select id="cfCostSelect">
                <option value="90">$90/MWh (Medium)</option>
                <option value="120">$120/MWh (Moderate)</option>
                <option value="150">$150/MWh (High &mdash; Lazard Nuclear)</option>
            </select>
        </div>
        <div class="region-context" id="regionContext"></div>
    </div>
    <div class="cf-cost-indicator" id="cfCostIndicator" style="display:none;">
        <span class="cf-indicator-icon">&#9888;</span>
        <span id="cfCostIndicatorText">Sensitivity scenario active: costs adjusted for clean firm at $X/MWh (medium model uses $90/MWh)</span>
    </div>

    <!-- SENSITIVITY TOGGLES (5 Paired Groups) -->
    <div class="sensitivity-panel" id="sensitivityPanel">
        <h3>Sensitivity Controls</h3>
        <p class="sensitivity-subtitle">Adjust cost assumptions to see how they change the optimal clean energy portfolio and total cost. Each toggle moves related technologies together, reflecting real-world cost correlations.</p>

        <div class="sensitivity-toggles-grid">
            <!-- 1. Renewable Generation Cost -->
            <div class="sensitivity-toggle-item" data-toggle-group="renewable_gen">
                <div class="toggle-label-area">
                    <div class="toggle-label-main">
                        Renewable Generation Cost
                        <span class="info-icon-wrapper" tabindex="0">
                            <span class="info-icon" aria-label="Info">i</span>
                            <span class="info-tooltip">Controls the assumed cost of building new solar and wind projects together. When renewable costs are <strong>Low</strong>, solar panels and wind turbines are cheap to build (e.g., technology breakthroughs). <strong>Medium</strong> reflects today's best estimates. <strong>High</strong> means supply chain problems or tariffs make them more expensive. This is the single biggest driver of clean energy cost.</span>
                        </span>
                    </div>
                    <div class="toggle-label-sub">Solar + Wind LCOE</div>
                </div>
                <div class="toggle-btn-group" data-toggle="renewable_gen" data-default="Medium">
                    <button data-value="Low" data-toggle-group="renewable_gen" data-level="Low">Low</button>
                    <button data-value="Medium" data-toggle-group="renewable_gen" data-level="Medium" class="active">Medium</button>
                    <button data-value="High" data-toggle-group="renewable_gen" data-level="High">High</button>
                </div>
            </div>

            <!-- 2. Firm Generation Cost -->
            <div class="sensitivity-toggle-item" data-toggle-group="firm_gen">
                <div class="toggle-label-area">
                    <div class="toggle-label-main">
                        Firm Generation Cost
                        <span class="info-icon-wrapper" tabindex="0">
                            <span class="info-icon" aria-label="Info">i</span>
                            <span class="info-tooltip">Controls the assumed cost of "always-on" clean power sources -- advanced nuclear and gas plants with carbon capture (CCS-CCGT). These resources run 24/7 regardless of weather. <strong>Low</strong> = favorable construction and policy support. <strong>Medium</strong> = current best estimates. <strong>High</strong> = project overruns or regulatory delays. Firm generation fills the gaps when sun and wind are unavailable.</span>
                        </span>
                    </div>
                    <div class="toggle-label-sub">Clean Firm + CCS-CCGT LCOE</div>
                </div>
                <div class="toggle-btn-group" data-toggle="firm_gen" data-default="Medium">
                    <button data-value="Low" data-toggle-group="firm_gen" data-level="Low">Low</button>
                    <button data-value="Medium" data-toggle-group="firm_gen" data-level="Medium" class="active">Medium</button>
                    <button data-value="High" data-toggle-group="firm_gen" data-level="High">High</button>
                </div>
            </div>

            <!-- 3. Storage Cost -->
            <div class="sensitivity-toggle-item" data-toggle-group="storage">
                <div class="toggle-label-area">
                    <div class="toggle-label-main">
                        Storage Cost
                        <span class="info-icon-wrapper" tabindex="0">
                            <span class="info-icon" aria-label="Info">i</span>
                            <span class="info-tooltip">Controls the assumed cost of energy storage -- both 4-hour lithium-ion batteries and 100-hour long-duration iron-air batteries. Storage captures excess solar/wind energy and releases it later. <strong>Low</strong> = rapid battery cost declines continue. <strong>Medium</strong> = current best estimates. <strong>High</strong> = lithium or iron supply constraints raise costs. Storage is critical for matching clean energy to demand hour-by-hour.</span>
                        </span>
                    </div>
                    <div class="toggle-label-sub">Battery (4hr) + LDES (100hr) LCOS</div>
                </div>
                <div class="toggle-btn-group" data-toggle="storage" data-default="Medium">
                    <button data-value="Low" data-toggle-group="storage" data-level="Low">Low</button>
                    <button data-value="Medium" data-toggle-group="storage" data-level="Medium" class="active">Medium</button>
                    <button data-value="High" data-toggle-group="storage" data-level="High">High</button>
                </div>
            </div>

            <!-- 4. Fossil Fuel Price -->
            <div class="sensitivity-toggle-item" data-toggle-group="fossil_fuel">
                <div class="toggle-label-area">
                    <div class="toggle-label-main">
                        Fossil Fuel Price
                        <span class="info-icon-wrapper" tabindex="0">
                            <span class="info-icon" aria-label="Info">i</span>
                            <span class="info-tooltip">Controls the price of natural gas, coal, and oil -- which together determine the wholesale electricity price you're comparing against. <strong>Low</strong> = cheap fossil fuels make grid power inexpensive (harder for clean energy to compete). <strong>Medium</strong> = current market prices. <strong>High</strong> = supply constraints or carbon pricing raise fossil costs (clean energy looks better by comparison).</span>
                        </span>
                    </div>
                    <div class="toggle-label-sub">Affects wholesale electricity price</div>
                </div>
                <div class="toggle-btn-group" data-toggle="fossil_fuel" data-default="Medium">
                    <button data-value="Low" data-toggle-group="fossil_fuel" data-level="Low">Low</button>
                    <button data-value="Medium" data-toggle-group="fossil_fuel" data-level="Medium" class="active">Medium</button>
                    <button data-value="High" data-toggle-group="fossil_fuel" data-level="High">High</button>
                </div>
            </div>

            <!-- 5. Transmission Cost -->
            <div class="sensitivity-toggle-item" data-toggle-group="transmission">
                <div class="toggle-label-area">
                    <div class="toggle-label-main">
                        Transmission Cost
                        <span class="info-icon-wrapper" tabindex="0">
                            <span class="info-icon" aria-label="Info">i</span>
                            <span class="info-tooltip">Controls the cost of connecting new clean energy projects to the grid. Every new solar farm or wind project needs transmission lines to deliver power. <strong>None</strong> = on-site generation or existing lines (no extra cost). <strong>Low</strong> = short, easy connections. <strong>Medium</strong> = typical new builds. <strong>High</strong> = long-distance or congested corridors requiring major new infrastructure.</span>
                        </span>
                    </div>
                    <div class="toggle-label-sub">All resource transmission adders</div>
                </div>
                <div class="toggle-btn-group" data-toggle="transmission" data-default="Medium">
                    <button data-value="None" data-toggle-group="transmission" data-level="None">None</button>
                    <button data-value="Low" data-toggle-group="transmission" data-level="Low">Low</button>
                    <button data-value="Medium" data-toggle-group="transmission" data-level="Medium" class="active">Medium</button>
                    <button data-value="High" data-toggle-group="transmission" data-level="High">High</button>
                </div>
            </div>
        </div>
    </div>

    <!-- WHAT YOU NEED DEPENDS ON WHAT YOU HAVE AND WHERE YOU'RE GOING -->
    <div class="what-you-need-panel" id="whatYouNeedPanel">
        <h3>What You Need Depends on What You Have &mdash; and Where You're Going</h3>
        <p class="wyn-subtitle">
            The chart compares the <strong>existing clean resources</strong> on the grid today with the
            <strong>optimal portfolios</strong> at your interim and long-term targets â€” in TWh, scaled by
            demand growth. When the long-term optimal mix differs from the interim, some of today's
            investment becomes <strong>stranded</strong>. Building strategically toward the end state
            from the start can save significant capital.
        </p>

        <div class="pathway-controls">
            <div class="pathway-ctrl">
                <label>Demand Growth <span class="info-icon-wrapper" tabindex="0"><span class="info-icon" aria-label="Info">i</span><span class="info-tooltip">Regional annual demand growth. Higher growth absorbs more interim procurement and reduces stranded investment. Rates are ISO-specific: ERCOT's data-center boom drives highest growth.</span></span></label>
                <div class="toggle-btn-group" data-toggle="demand_growth" data-default="Medium">
                    <button data-value="Low" data-toggle-group="demand_growth" data-level="Low">Low</button>
                    <button data-value="Medium" data-toggle-group="demand_growth" data-level="Medium" class="active">Medium</button>
                    <button data-value="High" data-toggle-group="demand_growth" data-level="High">High</button>
                </div>
                <div class="pathway-rate-display" id="demandRateDisplay" style="font-size:0.75rem; color:var(--text-muted); margin-top:4px;"></div>
            </div>
        </div>

        <div class="wyn-chart-container" style="height:360px;">
            <canvas id="wynCompareChart"></canvas>
        </div>

        <!-- Stranded Investment Metrics -->
        <div class="pathway-metrics" id="wynMetrics">
            <div class="pathway-metric">
                <div class="pathway-metric-value" id="pwCarriedForward">--</div>
                <div class="pathway-metric-label">Carried Forward</div>
                <div class="pathway-metric-sub">% of interim procurement useful at long-term target</div>
            </div>
            <div class="pathway-metric pathway-metric-warn">
                <div class="pathway-metric-value" id="pwWastedCost">--</div>
                <div class="pathway-metric-label">Stranded Investment</div>
                <div class="pathway-metric-sub">Estimated wasted cost from building toward interim instead of long-term</div>
            </div>
            <div class="pathway-metric">
                <div class="pathway-metric-value" id="pwDemandEffect">--</div>
                <div class="pathway-metric-label">Demand Growth Offset</div>
                <div class="pathway-metric-sub">How much demand growth reduces waste by absorbing surplus capacity</div>
            </div>
        </div>

        <div class="wyn-insight-box" id="wynInsightBox">
            Select a region and matching targets to see the resource pathway comparison.
        </div>
    </div>

    <!-- TARGET MODE TOGGLE (Interim / Long-term) -->
    <div class="target-mode-panel" id="targetModePanel">
        <div class="target-mode-label">Viewing:</div>
        <div class="target-mode-toggle" id="targetModeToggle">
            <button data-mode="interim" class="active">Interim Target</button>
            <button data-mode="longterm">Long-term Target</button>
        </div>
        <div class="target-mode-info" id="targetModeInfo">
            Showing <strong>interim</strong> target results. All charts below reflect the interim matching goal.
        </div>
    </div>

    <!-- METRIC TILES -->
    <div class="metrics-row">
        <div class="metric-tile" id="tileMatch">
            <div class="tile-label">Hourly Match Score</div>
            <div class="tile-value" id="metricMatch">--</div>
            <div class="tile-sub" id="metricMatchSub">of hours matched</div>
        </div>
        <div class="metric-tile" id="tileProcure">
            <div class="tile-label">Procurement Level</div>
            <div class="tile-value" id="metricProcure">--</div>
            <div class="tile-sub" id="metricProcureSub">of annual demand</div>
        </div>
        <div class="metric-tile" id="tileCost">
            <div class="tile-label">Incremental Cost</div>
            <div class="tile-value" id="metricCost">--</div>
            <div class="tile-sub" id="metricCostSub"></div>
        </div>
        <div class="metric-tile" id="tileCurtail">
            <div class="tile-label">Curtailment</div>
            <div class="tile-value" id="metricCurtail">--</div>
            <div class="tile-sub" id="metricCurtailSub">of procured energy</div>
        </div>
        <div class="metric-tile" id="tileCO2">
            <div class="tile-label">CO&#8322; Abated</div>
            <div class="tile-value" id="metricCO2Abated">--</div>
            <div class="tile-sub" id="metricCO2AbatedSub">tons</div>
        </div>
        <div class="metric-tile" id="tileAbateCost">
            <div class="tile-label">Abatement Cost</div>
            <div class="tile-value" id="metricAbateCost">--</div>
            <div class="tile-sub" id="metricAbateCostSub">$/ton CO&#8322; avg</div>
        </div>
    </div>

    <!-- KEY FINDING -->
    <div class="key-findings" id="keyFinding" style="display:none;">
        <h4>Key Finding</h4>
        <p id="keyFindingText"></p>
    </div>

    <!-- DONUT (Resource Mix) -->
    <div class="charts-row" style="grid-template-columns: 1fr 2fr;">
        <div class="chart-panel donut-panel">
            <h3>How Your Clean Energy is Sourced</h3>
            <div class="donut-container">
                <canvas id="donutChart"></canvas>
                <div class="donut-center-label">
                    <div class="dcl-value" id="donutCenterValue">--</div>
                    <div class="dcl-label">Hourly Match</div>
                </div>
            </div>
            <div class="donut-legend" id="donutLegend"></div>
        </div>
        <!-- COMPRESSED DAY -->
        <div class="chart-panel">
            <h3>A Typical Day: When Clean Energy Meets Demand</h3>
            <div class="compressed-day-container">
                <canvas id="compressedDayChart"></canvas>
            </div>
        </div>
    </div>

    <!-- COST BREAKDOWN -->
    <div class="charts-row" style="grid-template-columns:1fr;">
        <div class="cost-panel" id="costPanel">
            <h3>What You Pay: Cost Breakdown by Resource</h3>
            <div id="costContent"></div>
        </div>
    </div>

    <!-- PEAK CAPACITY ROW -->
    <div class="peak-cost-row" style="grid-template-columns:1fr;">
        <div class="peak-capacity-panel" id="peakCapacityPanel">
            <h3>Peak Hour: How Much Backup Capacity is Needed</h3>
            <div class="peak-capacity-visual" id="peakCapacityVisual">
                <!-- Populated by JS -->
            </div>
        </div>
    </div>
</div>

<!-- HERO TAKEAWAY BANNER (below results) -->
<div class="hero-takeaway" id="heroTakeaway" style="display:none;">
    <div class="hero-takeaway-icon">
        <svg width="28" height="28" viewBox="0 0 28 28" fill="none">
            <circle cx="14" cy="14" r="8" stroke="#1E3A5F" stroke-width="2" fill="none"/>
            <circle cx="14" cy="14" r="2.5" fill="#16A34A"/>
            <path d="M14 3 L14 6 M14 22 L14 25 M3 14 L6 14 M22 14 L25 14" stroke="#1E3A5F" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
    </div>
    <div class="hero-takeaway-headline">
        Investing in <em>clean firm power today</em> is the single<br>
        most important step toward deep decarbonization
    </div>
    <p class="hero-takeaway-sub">
        Our analysis of 8,760 hours across five U.S. power markets reveals that
        <strong>renewables alone cannot achieve high hourly matching targets</strong>.
        Beyond 90% matching, the cost curve inflects sharply and the resource mix pivots toward
        firm, dispatchable clean generation. Organizations that rely exclusively on wind and solar
        will face steep costs and stranded procurement as they pursue deeper decarbonization.
        <strong>Early investment in clean firm power significantly reduces long-term costs.</strong>
    </p>
</div>

<!-- FOOTER -->
<footer class="footer" id="footer" style="display:none;">
    Analysis based on 8,760-hour dispatch modeling &bull; Storage: 4h duration, 85% round-trip efficiency &bull;
    CO&#8322; accounting follows hourly matching protocol
</footer>

<script>
/* ====================================================================
   DASHBOARD CONTROLLER
   ==================================================================== */

// Disable datalabels globally; enable per-chart only where needed
if (typeof ChartDataLabels !== 'undefined') {
    Chart.defaults.set('plugins.datalabels', { display: false });
}

// Resource color map
const COLORS = {
    clean_firm: { base: '#1E3A5F', alpha: 'rgba(30,58,95,0.55)' },
    ccs_ccgt:   { base: '#0D9488', alpha: 'rgba(13,148,136,0.55)' },
    solar:      { base: '#F59E0B', alpha: 'rgba(245,158,11,0.55)' },
    wind:       { base: '#22C55E', alpha: 'rgba(34,197,94,0.55)' },
    hydro:      { base: '#0EA5E9', alpha: 'rgba(14,165,233,0.55)' },
    battery:    { base: '#8B5CF6', alpha: 'rgba(139,92,246,0.55)' },
    ldes:       { base: '#EC4899', alpha: 'rgba(236,72,153,0.55)' },
    storage:    { base: '#EF4444', alpha: 'rgba(239,68,68,0.55)' },
    gap:        { base: '#D1D5DB', alpha: 'rgba(209,213,219,0.55)' }
};

const RESOURCE_LABELS = {
    clean_firm: 'Clean Firm (Nuc+Geo)',
    ccs_ccgt: 'CCS-CCGT',
    solar: 'Solar',
    wind: 'Wind',
    hydro: 'Hydro',
    battery: 'Battery (4hr)',
    ldes: 'LDES (100hr)',
    storage: 'Storage'
};

const OUTLINE_COLOR = '#374151';
const NAVY = '#1A2744';

let DATA = null;
let donutChart = null;
let compressedDayChart = null;
let currentTargetMode = 'interim'; // 'interim' or 'longterm'

// ---- Helpers ----
function formatNum(n, decimals = 0) {
    if (n == null || isNaN(n)) return '--';
    return Number(n).toFixed(decimals);
}

function formatPct(n, decimals = 0) {
    return formatNum(n, decimals) + '%';
}

function formatCommas(n) {
    if (n == null) return '--';
    return Number(n).toLocaleString('en-US');
}

// Create a striped canvas pattern for surplus
function createStripePattern(ctx, color, bgColor) {
    const patternCanvas = document.createElement('canvas');
    patternCanvas.width = 10;
    patternCanvas.height = 10;
    const pctx = patternCanvas.getContext('2d');
    pctx.fillStyle = bgColor || 'rgba(255,255,255,0.3)';
    pctx.fillRect(0, 0, 10, 10);
    pctx.strokeStyle = color;
    pctx.lineWidth = 2;
    pctx.beginPath();
    pctx.moveTo(0, 10);
    pctx.lineTo(10, 0);
    pctx.stroke();
    pctx.beginPath();
    pctx.moveTo(-2, 2);
    pctx.lineTo(2, -2);
    pctx.stroke();
    pctx.beginPath();
    pctx.moveTo(8, 12);
    pctx.lineTo(12, 8);
    pctx.stroke();
    return ctx.createPattern(patternCanvas, 'repeat');
}

// ---- Scenario Resolver ----
// Maps the 5 sensitivity toggle states to a scenario key like "MMM_M_M"
function buildScenarioKey() {
    const levelMap = { 'Low': 'L', 'Medium': 'M', 'High': 'H', 'None': 'N' };
    const rg = levelMap[sensitivityState.renewable_gen] || 'M';
    const fg = levelMap[sensitivityState.firm_gen] || 'M';
    const st = levelMap[sensitivityState.storage] || 'M';
    const ff = levelMap[sensitivityState.fossil_fuel] || 'M';
    const tx = levelMap[sensitivityState.transmission] || 'M';
    return `${rg}${fg}${st}_${ff}_${tx}`;
}

// Resolves a threshold entry from the new scenario-based data format.
// Returns a normalized entry compatible with the dashboard's expected field names.
function resolveEntry(region, thresholdKey) {
    const thresholdData = region.thresholds?.[thresholdKey];
    if (!thresholdData) return null;

    // New format: thresholdData.scenarios is a dict keyed by scenario strings
    if (thresholdData.scenarios) {
        const key = buildScenarioKey();
        let scenario = thresholdData.scenarios[key];
        // Fallback: if the exact key isn't available, try MMM_M_M, then first available
        if (!scenario) scenario = thresholdData.scenarios['MMM_M_M'];
        if (!scenario) {
            const keys = Object.keys(thresholdData.scenarios);
            if (keys.length > 0) scenario = thresholdData.scenarios[keys[0]];
        }
        if (!scenario) return null;
        return normalizeEntry(scenario);
    }

    // Legacy flat format (no scenarios dict) â€” pass through
    return thresholdData;
}

// Normalizes a scenario entry so the dashboard can read it uniformly.
// Merges costs_detail into costs, maps co2 fields, etc.
function normalizeEntry(raw) {
    const entry = Object.assign({}, raw);

    // Merge costs_detail into costs for backward compatibility
    const detail = raw.costs_detail || {};
    const summary = raw.costs || {};

    // Build resource_costs with merged storage from battery + ldes
    const rc = detail.resource_costs ? Object.assign({}, detail.resource_costs) : null;
    if (rc && !rc.storage && (rc.battery || rc.ldes)) {
        const bat = rc.battery || {};
        const ldes = rc.ldes || {};
        rc.storage = {
            dispatch_pct: (bat.dispatch_pct || 0) + (ldes.dispatch_pct || 0),
            cost_per_demand_mwh: (bat.cost_per_demand_mwh || 0) + (ldes.cost_per_demand_mwh || 0)
        };
    }

    entry.costs = {
        total_cost_per_demand_mwh: detail.total_cost_per_demand_mwh ?? summary.total_cost ?? null,
        effective_cost_per_useful_mwh: detail.effective_cost_per_useful_mwh ?? summary.effective_cost ?? null,
        baseline_wholesale_cost: detail.baseline_wholesale_cost ?? summary.wholesale ?? null,
        incremental_above_baseline: detail.incremental_above_baseline ?? summary.incremental ?? null,
        curtailment_pct: detail.curtailment_pct ?? null,
        resource_costs: rc
    };

    // Map CO2 data to flat field
    if (raw.co2_abated && raw.co2_abated.total_co2_abated_tons != null) {
        entry.co2_abated_tons = raw.co2_abated.total_co2_abated_tons;
        entry.co2_rate_per_mwh = raw.co2_abated.co2_rate_per_mwh;
    }

    // Map storage dispatch fields
    const batDisp = raw.battery_dispatch_pct || 0;
    const ldesDisp = raw.ldes_dispatch_pct || 0;
    entry.storage_dispatch_pct = batDisp + ldesDisp;

    return entry;
}

// ---- Data Loading ----
async function loadData() {
    try {
        const resp = await fetch('overprocure_results.json');
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        DATA = await resp.json();
        initDashboard();
    } catch (err) {
        showError(err);
    }
}

function showError(err) {
    document.getElementById('loadingState').style.display = 'none';
    const el = document.getElementById('errorState');
    el.style.display = 'block';
    el.innerHTML = `
        <div class="error-message">
            <h2>Results Not Yet Available</h2>
            <p>Could not load <code>overprocure_results.json</code>.</p>
            <p style="margin-top:8px;">Run <code>optimize_overprocure.py</code> first to generate the analysis results.</p>
            <p style="margin-top:12px;font-size:0.8rem;color:#997a00;">${err.message || err}</p>
        </div>
    `;
}

// ---- Clean Firm Cost Sensitivity ----
let selectedCfCost = 90; // baseline

/**
 * Calculate cost adjustment for a given entry when clean firm LCOE changes.
 * Returns { totalDelta, effectiveDelta, newTotal, newEffective, newIncremental, cfCostDelta }
 */
function cfAdjust(entry, iso) {
    if (selectedCfCost === 90 || !entry?.costs?.resource_costs?.clean_firm) {
        const c = entry?.costs || {};
        return {
            totalDelta: 0,
            effectiveDelta: 0,
            newTotal: c.total_cost_per_demand_mwh || 0,
            newEffective: c.effective_cost_per_useful_mwh || 0,
            newIncremental: c.incremental_above_baseline || 0,
            cfCostDelta: 0,
            newCfCostPerMwh: c.resource_costs?.clean_firm?.cost_per_demand_mwh || 0,
        };
    }
    const costs = entry.costs;
    const cf = costs.resource_costs.clean_firm;
    const newPct = cf.new_pct || 0; // % of demand that is new-build clean firm
    const priceDelta = selectedCfCost - 90;
    const totalDelta = (newPct / 100) * priceDelta;
    const newTotal = costs.total_cost_per_demand_mwh + totalDelta;
    const proc = entry.procurement_pct / 100;
    const match = entry.hourly_match_score / 100;
    const newEffective = match > 0 ? newTotal * proc / match : newTotal;
    const baseline = costs.baseline_wholesale_cost || 0;
    const newIncremental = newEffective - baseline;
    const newCfCostPerMwh = cf.cost_per_demand_mwh + (newPct / 100) * priceDelta;
    return { totalDelta, effectiveDelta: newEffective - costs.effective_cost_per_useful_mwh, newTotal, newEffective, newIncremental, cfCostDelta: totalDelta, newCfCostPerMwh };
}

/**
 * Get adjusted effective cost for a threshold across ISOs (for narrative charts)
 */
function getAdjustedEffectiveCost(iso, thresholdKey) {
    const region = DATA.results[iso];
    if (!region) return null;
    const t = resolveEntry(region, thresholdKey);
    if (!t?.costs) return null;
    const adj = cfAdjust(t, iso);
    return adj.newEffective;
}

function updateCfIndicator() {
    const indicator = document.getElementById('cfCostIndicator');
    if (!indicator) return;
    if (selectedCfCost === 90) {
        indicator.style.display = 'none';
    } else {
        indicator.style.display = 'flex';
        document.getElementById('cfCostIndicatorText').innerHTML =
            `<strong>Sensitivity scenario active:</strong> All costs adjusted for new-build clean firm at <strong>$${selectedCfCost}/MWh</strong> (medium estimate is $90/MWh). Resource mix and curtailment are unchanged &mdash; only cost figures are affected.`;
    }
}

function onCfCostChange() {
    selectedCfCost = parseInt(document.getElementById('cfCostSelect').value, 10);
    updateCfIndicator();
    updateAll();
    // Re-render narrative sections if they've been initialized
    if (narrativeCostChart) refreshNarrativeCostChart();
    refreshNarrativeStats();
}

// ---- Initialize ----
function initDashboard() {
    document.getElementById('loadingState').style.display = 'none';
    document.getElementById('dashboardContent').style.display = 'block';
    document.getElementById('heroTakeaway').style.display = 'block';
    document.getElementById('footer').style.display = 'block';
    // Narrative sections moved to index.html

    // Config info
    const cfg = DATA.config;
    const yearLabel = document.getElementById('dataYearLabel');
    if (yearLabel) yearLabel.textContent =
        `Data Year: ${cfg.data_year} \u2022 Battery: ${cfg.battery_duration || '4h'} / ${((cfg.battery_efficiency || 0.85) * 100).toFixed(0)}% RTE \u2022 LDES: ${cfg.ldes_duration || '100h'} / ${((cfg.ldes_efficiency || 0.5) * 100).toFixed(0)}% RTE \u2022 ${cfg.resource_types.map(r => RESOURCE_LABELS[r] || r).join(', ')}`;

    // Populate region dropdown
    const regionSel = document.getElementById('regionSelect');
    const isos = Object.keys(DATA.results);
    isos.forEach(iso => {
        const opt = document.createElement('option');
        opt.value = iso;
        opt.textContent = DATA.results[iso].label;
        regionSel.appendChild(opt);
    });

    // Populate threshold dropdown â€” 10 modeled thresholds only
    const threshSel = document.getElementById('thresholdSelect');
    const FULL_THRESHOLDS = [75, 80, 85, 87.5, 90, 92.5, 95, 97.5, 99, 100];
    FULL_THRESHOLDS.forEach(t => {
        const opt = document.createElement('option');
        opt.value = String(t);
        opt.textContent = `${t}%`;
        threshSel.appendChild(opt);
    });
    // Default to 75% interim
    threshSel.value = '75';

    // Bind events
    regionSel.addEventListener('change', updateAll);
    threshSel.addEventListener('change', updateAll);
    const cfCostSel = document.getElementById('cfCostSelect');
    if (cfCostSel) cfCostSel.addEventListener('change', onCfCostChange);

    // Initialize sensitivity toggle buttons
    initSensitivityToggles();

    // Initialize target mode toggle (interim / long-term)
    initTargetModeToggle();

    // Initialize pathway analysis (interim â†’ long-term target with demand growth)
    initPathwayAnalysis();

    updateAll();

    // Initialize mobile inline step charts after a short delay for layout
    setTimeout(initMobileStepCharts, 400);
}

// ---- Find closest available threshold ----
function findClosestThreshold(region, requestedThreshold) {
    const requested = parseFloat(requestedThreshold);
    // Check if the exact threshold exists and has scenario data
    const td = region.thresholds[String(requested)];
    if (td && (!td.scenarios || Object.keys(td.scenarios).length > 0)) return String(requested);
    // Find the closest available threshold that has scenario data
    const available = Object.keys(region.thresholds)
        .filter(k => {
            const d = region.thresholds[k];
            return !d.scenarios || Object.keys(d.scenarios).length > 0;
        })
        .map(Number).sort((a, b) => a - b);
    if (available.length === 0) return requestedThreshold;
    let closest = available[0];
    let minDiff = Math.abs(requested - closest);
    for (const t of available) {
        const diff = Math.abs(requested - t);
        if (diff < minDiff) { minDiff = diff; closest = t; }
    }
    return String(closest);
}

// ---- Resolve the active entry based on target mode ----
function getActiveEntry(region) {
    const interimThreshold = findClosestThreshold(region, document.getElementById('thresholdSelect').value);
    const interimEntry = resolveEntry(region, interimThreshold);
    if (currentTargetMode === 'longterm') {
        const longtermVal = document.getElementById('longtermTarget').value;
        if (longtermVal) {
            const longtermThreshold = findClosestThreshold(region, longtermVal);
            const longtermEntry = resolveEntry(region, longtermThreshold);
            if (longtermEntry) return { entry: longtermEntry, threshold: longtermThreshold };
        }
    }
    return { entry: interimEntry, threshold: interimThreshold };
}

// ---- Update everything ----
function updateAll() {
    const iso = document.getElementById('regionSelect').value;
    const requestedThreshold = document.getElementById('thresholdSelect').value;
    const region = DATA.results[iso];
    // Fallback to closest available if this threshold isn't in the data
    const interimThreshold = findClosestThreshold(region, requestedThreshold);
    const interimEntry = resolveEntry(region, interimThreshold);
    if (!interimEntry) return;

    // Resolve which entry to show for charts from donut onward
    const active = getActiveEntry(region);
    const displayEntry = active.entry;
    const displayThreshold = active.threshold;

    updateRegionContext(region);
    updateTargetModeInfo();
    updateMetrics(region, displayEntry);
    updateKeyFinding(iso, displayThreshold, displayEntry, region);
    updateDonut(displayEntry);
    updateCompressedDay(displayEntry, region, iso);
    updatePeakCapacity(displayEntry, region);
    updateCostPanel(displayEntry);
    updateWhatYouNeedPanel(region, interimEntry, interimThreshold);
    updateCO2Tile(displayEntry);
    updateHeatmapTiles(region, displayEntry, iso);
    updatePathwayAnalysis();
}

// ---- Key Finding ----
function updateKeyFinding(iso, threshold, entry, region) {
    const kfDiv = document.getElementById('keyFinding');
    const kfText = document.getElementById('keyFindingText');
    kfDiv.style.display = 'block';

    const match = Math.round(entry.hourly_match_score);
    const proc = entry.procurement_pct;
    const adj = cfAdjust(entry, iso);
    const incr = adj.newIncremental > 0 ? Math.round(adj.newIncremental) : null;
    const costs = entry.costs || {};
    const curt = costs.curtailment_pct ? Math.round(costs.curtailment_pct) : 0;
    const peak = Math.round(entry.peak_gap_pct || 0);
    const mix = entry.resource_mix || {};
    const dominant = Object.entries(mix).sort((a,b) => b[1] - a[1])[0];
    const dominantName = dominant[0].replace('clean_firm', 'clean firm');
    const dominantPct = dominant[1];
    const isoLabel = region.label.split(' (')[0];
    const cfTag = selectedCfCost !== 90 ? ` <span style="color:#D97706;font-size:0.85em;">(CF@$${selectedCfCost})</span>` : '';

    let text = '';
    if (proc <= 100) {
        text = `In <span class="kf-value">${isoLabel}</span>, achieving a ` +
            `<span class="kf-value">${match}%</span> hourly match requires only ` +
            `<span class="kf-value">${proc}%</span> annual procurement with a mix dominated by ` +
            `<span class="kf-value">${dominantPct}% ${dominantName}</span>.`;
    } else {
        text = `In <span class="kf-value">${isoLabel}</span>, reaching a ` +
            `<span class="kf-value">${match}%</span> hourly match requires ` +
            `<span class="kf-value">${proc}%</span> procurement`;
        if (incr !== null) {
            text += ` at an incremental cost of <span class="kf-accent">+$${incr}/MWh</span>${cfTag}`;
        }
        text += `.`;
        if (curt > 0) {
            text += ` About <span class="kf-accent">${curt}%</span> of procured energy is curtailed.`;
        }
    }
    if (peak > 0) {
        text += ` Even at this level, the worst single hour still has a ` +
            `<span class="kf-value">${peak}%</span> backup capacity requirement.`;
    }
    kfText.innerHTML = text;
}

// ---- Region Context ----
function updateRegionContext(region) {
    const ctx = document.getElementById('regionContext');
    const demandTWh = (region.annual_demand_mwh / 1e6).toFixed(0);
    const peakGW = (region.peak_demand_mw / 1000).toFixed(0);
    ctx.innerHTML = `
        <span>
            <span class="ctx-label">Annual Demand</span>
            <span class="ctx-value">${demandTWh} TWh</span>
        </span>
        <span>
            <span class="ctx-label">Peak Demand</span>
            <span class="ctx-value">${formatCommas(region.peak_demand_mw)} MW (${peakGW} GW)</span>
        </span>
    `;
}

// ---- Metrics ----
function updateMetrics(region, entry) {
    const iso = document.getElementById('regionSelect').value;
    document.getElementById('metricMatch').textContent = formatPct(entry.hourly_match_score);
    document.getElementById('metricMatchSub').textContent = 'of hours matched';

    document.getElementById('metricProcure').textContent = entry.procurement_pct + '%';
    const overAmt = entry.procurement_pct - 100;
    document.getElementById('metricProcureSub').textContent =
        overAmt > 0 ? `+${overAmt}% above demand` : 'at demand level';

    // Cost tile: bold = incremental, sub = blended
    const costs = entry.costs;
    if (costs && costs.effective_cost_per_useful_mwh != null) {
        const adj = cfAdjust(entry, iso);
        if (costs.incremental_above_baseline != null) {
            document.getElementById('metricCost').textContent = '+$' + formatNum(adj.newIncremental) + '/MWh';
            document.getElementById('metricCostSub').innerHTML =
                `$${formatNum(adj.newEffective)}/MWh blended` +
                (selectedCfCost !== 90 ? ` <span style="color:#D97706;font-size:0.78rem;">(CF@$${selectedCfCost})</span>` : '');
        } else {
            document.getElementById('metricCost').textContent = '$' + formatNum(adj.newEffective);
            document.getElementById('metricCostSub').textContent = 'per MWh (effective)';
        }
    } else {
        document.getElementById('metricCost').textContent = '--';
        document.getElementById('metricCostSub').textContent = 'cost data not available';
    }

    // Curtailment
    const curtTile = document.getElementById('metricCurtail').closest('.metric-tile');
    if (costs && costs.curtailment_pct != null) {
        document.getElementById('metricCurtail').textContent = formatPct(costs.curtailment_pct);
        document.getElementById('metricCurtailSub').textContent = 'of procured energy';
        curtTile.classList.toggle('tile-negative', costs.curtailment_pct > 0);
    } else {
        // Estimate curtailment from procurement
        const curtEst = entry.procurement_pct > 100 ? (entry.procurement_pct - 100) : 0;
        const matchDelta = 100 - entry.hourly_match_score;
        // rough estimate: surplus procurement minus the gap improvements
        document.getElementById('metricCurtail').textContent =
            curtEst > 0 ? ('~' + formatPct(curtEst, 0)) : '0%';
        document.getElementById('metricCurtailSub').textContent =
            curtEst > 0 ? 'estimated from surplus procurement' : 'no surplus procurement';
        curtTile.classList.toggle('tile-negative', curtEst > 0);
    }
}

// ---- Donut Chart ----
function updateDonut(entry) {
    const mix = entry.resource_mix;
    const matchScore = entry.hourly_match_score || 0;
    const battPct = entry.battery_dispatch_pct || 0;
    const ldesPct = entry.ldes_dispatch_pct || 0;

    // All 5 generation resources from resource_mix
    const genResources = ['clean_firm', 'ccs_ccgt', 'solar', 'wind', 'hydro'];
    const mixTotal = genResources.reduce((s, r) => s + (mix[r] || 0), 0) || 100;

    // Storage dispatch contributes to match score but isn't in resource_mix
    const storageTotal = battPct + ldesPct;
    const genMatch = Math.max(0, matchScore - storageTotal);

    const labels = [];
    const values = [];
    const bgColors = [];
    const borderColors = [];

    // Scale generation resources to their share of demand matched
    genResources.forEach(r => {
        const mixPct = mix[r] || 0;
        const scaledVal = (mixPct / mixTotal) * genMatch;
        if (scaledVal > 0.3) {
            labels.push(RESOURCE_LABELS[r]);
            values.push(Math.round(scaledVal * 10) / 10);
            bgColors.push(COLORS[r].alpha);
            borderColors.push(OUTLINE_COLOR);
        }
    });

    // Battery and LDES as separate slices
    if (battPct > 0.3) {
        labels.push(RESOURCE_LABELS.battery);
        values.push(Math.round(battPct * 10) / 10);
        bgColors.push(COLORS.battery.alpha);
        borderColors.push(OUTLINE_COLOR);
    }
    if (ldesPct > 0.3) {
        labels.push(RESOURCE_LABELS.ldes);
        values.push(Math.round(ldesPct * 10) / 10);
        bgColors.push(COLORS.ldes.alpha);
        borderColors.push(OUTLINE_COLOR);
    }

    // Gap slice
    const gapPct = Math.max(0, 100 - matchScore);
    if (gapPct > 0.5) {
        labels.push('Unmatched');
        values.push(Math.round(gapPct * 10) / 10);
        bgColors.push(COLORS.gap.alpha);
        borderColors.push(OUTLINE_COLOR);
    }

    // Center label
    document.getElementById('donutCenterValue').textContent = formatPct(matchScore);

    // Legend
    const legendEl = document.getElementById('donutLegend');
    let legendHTML = '';
    labels.forEach((lbl, i) => {
        legendHTML += `
            <div class="donut-legend-item">
                <div class="donut-legend-swatch" style="background:${bgColors[i]}"></div>
                <span>${lbl}: ${values[i]}%</span>
            </div>`;
    });
    legendEl.innerHTML = legendHTML;

    const ctx = document.getElementById('donutChart').getContext('2d');

    if (donutChart) {
        donutChart.data.labels = labels;
        donutChart.data.datasets[0].data = values;
        donutChart.data.datasets[0].backgroundColor = bgColors;
        donutChart.data.datasets[0].borderColor = borderColors;
        donutChart.update('active');
    } else {
        donutChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: labels,
                datasets: [{
                    data: values,
                    backgroundColor: bgColors,
                    borderColor: borderColors,
                    borderWidth: 2,
                    hoverBorderWidth: 2.5,
                    hoverOffset: 6
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                cutout: '62%',
                layout: { padding: 6 },
                animation: {
                    animateRotate: true,
                    duration: 600
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'rgba(26,39,68,0.92)',
                        titleFont: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 13, weight: '600' },
                        bodyFont: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12 },
                        padding: 12,
                        cornerRadius: 8,
                        callbacks: {
                            label: function(context) {
                                return ` ${context.label}: ${context.parsed.toFixed(1)}% of demand`;
                            }
                        }
                    }
                }
            }
        });
    }
}

// ---- Compressed Day Chart ----
function updateCompressedDay(entry, region, iso) {
    const cd = entry.compressed_day;
    if (!cd) {
        // No compressed day data
        const ctx = document.getElementById('compressedDayChart').getContext('2d');
        if (compressedDayChart) {
            compressedDayChart.destroy();
            compressedDayChart = null;
        }
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.fillStyle = '#6B7280';
        ctx.font = "14px 'Barlow Semi Condensed', 'Arial Narrow', sans-serif";
        ctx.textAlign = 'center';
        ctx.fillText('Compressed day profile not available for this selection.', ctx.canvas.width / 2, ctx.canvas.height / 2);
        return;
    }

    // UTC offsets: optimizer data is in UTC hour-of-day; rotate to local time
    // These are standard-time offsets (hours behind UTC). We use a weighted
    // average that accounts for ~58% of hours being in DST (Mar-Nov).
    const UTC_OFFSETS = {CAISO: 8, ERCOT: 6, PJM: 5, NYISO: 5, NEISO: 5};
    const stdOff = UTC_OFFSETS[iso] || 5;
    // Rotate array left by stdOff positions to convert UTC â†’ local
    const rotateToLocal = (arr) => [...arr.slice(stdOff), ...arr.slice(0, stdOff)];

    const hours = Array.from({length: 24}, (_, i) => i);
    const hourLabels = hours.map(h => {
        if (h === 0) return '12am';
        if (h < 12) return h + 'am';
        if (h === 12) return '12pm';
        return (h - 12) + 'pm';
    });

    // Convert normalized sums to MW (representative daily average)
    // Each value is the sum of normalized hourly values across 365 days
    // Divide by 365 and multiply by annual_demand to get average MW for that hour
    const annualMWh = region.annual_demand_mwh || 1;
    const toMW = (v) => (v / 365) * annualMWh;

    // Rotate all compressed-day arrays from UTC to local time, then convert to MW
    const r = (arr) => rotateToLocal(arr).map(v => Math.max(0, toMW(v)));
    const rRaw = (arr) => rotateToLocal(arr).map(v => toMW(v));
    const z24 = new Array(24).fill(0);

    // Calculate stacked matched values (in MW, local time) â€” all 7 resource types
    const matchedCleanFirm = r(cd.matched.clean_firm || z24);
    const matchedCCS = r(cd.matched.ccs_ccgt || z24);
    const matchedSolar = r(cd.matched.solar || z24);
    const matchedWind = r(cd.matched.wind || z24);
    const matchedHydro = r(cd.matched.hydro || z24);
    const matchedBattery = r(cd.matched.battery || cd.matched.storage || z24);
    const matchedLDES = r(cd.matched.ldes || z24);

    // Separate charging for battery and LDES (negative, below x-axis) â€” in MW, local time
    const batteryCharge = rRaw(cd.battery_charge || z24);
    const ldesCharge = rRaw(cd.ldes_charge || z24);

    // Per-resource surplus (curtailed) â€” in MW, local time
    const surplusSolar = rRaw(cd.surplus?.solar || z24);
    const surplusWind = rRaw(cd.surplus?.wind || z24);
    const surplusHydro = rRaw(cd.surplus?.hydro || z24);
    const surplusCleanFirm = rRaw(cd.surplus?.clean_firm || z24);
    const surplusCCS = rRaw(cd.surplus?.ccs_ccgt || z24);

    // Gap (unmatched) â€” in MW, local time
    const gap = rRaw(cd.gap);

    // Build stacked bottom-up: clean_firm, ccs_ccgt, hydro, wind, solar, battery, ldes
    // Then per-resource surplus on top (color-coded cross-hatching)

    const ctx = document.getElementById('compressedDayChart').getContext('2d');

    // Create per-resource stripe patterns for surplus
    const surplusPatterns = {
        solar: createStripePattern(ctx, COLORS.solar.base, 'rgba(245,158,11,0.18)'),
        wind: createStripePattern(ctx, COLORS.wind.base, 'rgba(34,197,94,0.18)'),
        hydro: createStripePattern(ctx, COLORS.hydro.base, 'rgba(14,165,233,0.18)'),
        clean_firm: createStripePattern(ctx, COLORS.clean_firm.base, 'rgba(26,39,68,0.18)'),
        ccs_ccgt: createStripePattern(ctx, COLORS.ccs_ccgt.base, 'rgba(13,148,136,0.18)')
    };

    // Build cumulative stacking arrays (bottom to top)
    const stack0 = matchedCleanFirm;
    const stack1 = stack0.map((v, i) => v + matchedCCS[i]);
    const stack2 = stack1.map((v, i) => v + matchedHydro[i]);
    const stack3 = stack2.map((v, i) => v + matchedWind[i]);
    const stack4 = stack3.map((v, i) => v + matchedSolar[i]);
    const stack5 = stack4.map((v, i) => v + matchedBattery[i]);
    const matchedTotal = stack5.map((v, i) => v + matchedLDES[i]);

    const dsBase = { borderColor: OUTLINE_COLOR, borderWidth: 1.5, pointRadius: 0, pointHoverRadius: 0, tension: 0.3 };

    const datasets = [
        { ...dsBase, label: RESOURCE_LABELS.clean_firm, data: stack0, backgroundColor: COLORS.clean_firm.alpha, fill: 'origin', order: 11 },
        { ...dsBase, label: RESOURCE_LABELS.ccs_ccgt,   data: stack1, backgroundColor: COLORS.ccs_ccgt.alpha,   fill: '-1',     order: 10 },
        { ...dsBase, label: RESOURCE_LABELS.hydro,      data: stack2, backgroundColor: COLORS.hydro.alpha,      fill: '-1',     order: 9 },
        { ...dsBase, label: RESOURCE_LABELS.wind,       data: stack3, backgroundColor: COLORS.wind.alpha,       fill: '-1',     order: 8 },
        { ...dsBase, label: RESOURCE_LABELS.solar,      data: stack4, backgroundColor: COLORS.solar.alpha,      fill: '-1',     order: 7 },
        { ...dsBase, label: RESOURCE_LABELS.battery,    data: stack5, backgroundColor: COLORS.battery.alpha,    fill: '-1',     order: 6 },
        { ...dsBase, label: RESOURCE_LABELS.ldes,       data: matchedTotal.slice(), backgroundColor: COLORS.ldes.alpha, fill: '-1', order: 5 }
    ];

    // Remember the index of the LDES dataset (top of matched stack)
    const topMatchedIdx = datasets.length - 1;

    // Battery charging (shown as negative below the x-axis)
    const hasBattCharge = batteryCharge.some(v => v > 0.001);
    if (hasBattCharge) {
        datasets.push({
            ...dsBase, label: 'Battery Charge', data: batteryCharge.map(v => -Math.abs(v)),
            backgroundColor: 'rgba(139,92,246,0.30)', borderColor: COLORS.battery.base,
            fill: 'origin', order: 13, _isCharge: true
        });
    }

    // LDES charging (shown as negative below the x-axis, stacked under battery charge)
    const hasLdesCharge = ldesCharge.some(v => v > 0.001);
    if (hasLdesCharge) {
        const ldesChargeData = ldesCharge.map((v, i) => {
            const battBase = hasBattCharge ? -Math.abs(batteryCharge[i]) : 0;
            return battBase - Math.abs(v);
        });
        datasets.push({
            ...dsBase, label: 'LDES Charge', data: ldesChargeData,
            backgroundColor: 'rgba(236,72,153,0.30)', borderColor: COLORS.ldes.base,
            fill: hasBattCharge ? '-1' : 'origin', order: 14, _isCharge: true
        });
    }

    // Curtailment order: solar first, then wind, hydro, ccs, clean firm last
    const curtailOrder = ['solar', 'wind', 'hydro', 'ccs_ccgt', 'clean_firm'];
    const surplusArrays = { solar: surplusSolar, wind: surplusWind, hydro: surplusHydro, ccs_ccgt: surplusCCS, clean_firm: surplusCleanFirm };
    let curtailCumulative = matchedTotal.slice();
    let prevCurtailIdx = topMatchedIdx;

    for (const rt of curtailOrder) {
        const surpVals = surplusArrays[rt];
        const hasSurplus = surpVals.some(v => v > 1);
        if (!hasSurplus) continue;

        const stackedData = surpVals.map((v, i) => {
            curtailCumulative[i] += Math.max(0, v);
            return curtailCumulative[i];
        });

        const thisIdx = datasets.length;
        datasets.push({
            label: (RESOURCE_LABELS[rt] || rt) + ' (Curtailed)',
            data: stackedData,
            backgroundColor: surplusPatterns[rt],
            borderColor: COLORS[rt].base,
            borderWidth: 0.5,
            borderDash: [3, 3],
            fill: { target: prevCurtailIdx, above: surplusPatterns[rt] },
            pointRadius: 0,
            pointHoverRadius: 0,
            tension: 0.3,
            order: 4 - curtailOrder.indexOf(rt),
            _surplusVals: surpVals
        });
        prevCurtailIdx = thisIdx;
    }

    // Demand line on top
    datasets.push({
        label: 'Demand',
        data: rRaw(cd.demand),
        backgroundColor: 'transparent',
        borderColor: '#1a1a2e',
        borderWidth: 2.5,
        borderDash: [6, 4],
        fill: false,
        pointRadius: 0,
        pointHoverRadius: 0,
        tension: 0.3,
        order: -1
    });

    // Add gap dataset if there's any gap (tooltip only)
    const hasGap = gap.some(v => v > 0.0001);
    if (hasGap) {
        const demandLocal = rRaw(cd.demand);
        datasets.push({
            label: 'Unmatched (Gap)',
            data: demandLocal.map((d, i) => Math.max(0, d - matchedTotal[i])),
            backgroundColor: COLORS.gap.alpha,
            borderColor: OUTLINE_COLOR,
            borderWidth: 1.5,
            fill: false,
            pointRadius: 0,
            pointHoverRadius: 0,
            tension: 0.3,
            order: 15,
            hidden: true
        });
    }

    if (compressedDayChart) {
        compressedDayChart.data.labels = hourLabels;
        compressedDayChart.data.datasets = datasets;
        compressedDayChart.update('active');
    } else {
        compressedDayChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: hourLabels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: { duration: 500 },
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                scales: {
                    x: {
                        grid: { display: false }, border: { display: true, color: '#D4D8E0' },
                        ticks: {
                            font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11 },
                            color: '#6B6356',
                            maxRotation: 0
                        }
                    },
                    y: {
                        grid: { display: false }, border: { display: true, color: '#D4D8E0' },
                        ticks: {
                            font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11 },
                            color: '#6B6356',
                            callback: function(v) {
                                const abs = Math.abs(v);
                                const label = abs >= 1000 ? (abs/1000).toFixed(0) + 'k' : abs.toFixed(0);
                                return v < 0 ? '-' + label : label;
                            }
                        },
                        title: {
                            display: true,
                            text: 'Average MW',
                            font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12, weight: '600' },
                            color: '#4A4540'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: {
                            font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 10 },
                            color: '#1A1A1A',
                            usePointStyle: true,
                            pointStyle: 'rectRounded',
                            padding: 8,
                            boxWidth: 10,
                            boxHeight: 10,
                            filter: function(item) {
                                // Hide gap, charging, and curtailed from legend to keep it compact
                                const t = item.text;
                                return t !== 'Unmatched (Gap)' && !t.includes('Charge') && !t.includes('Curtailed');
                            }
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(26,39,68,0.92)',
                        titleFont: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 13, weight: '600' },
                        bodyFont: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12 },
                        padding: 12,
                        cornerRadius: 8,
                        callbacks: {
                            label: function(context) {
                                const ds = context.dataset;
                                const fmtMW = (v) => {
                                    const abs = Math.abs(v);
                                    const s = abs >= 1000 ? Math.round(abs).toLocaleString() + ' MW' : abs.toFixed(0) + ' MW';
                                    return v < 0 ? '-' + s : s;
                                };
                                if (ds.label === 'Demand') {
                                    return ` Demand: ${fmtMW(context.parsed.y)}`;
                                }
                                if (ds.label === 'Unmatched (Gap)') return null;
                                // Storage charge (negative) â€” show specific label
                                if (ds._isCharge) {
                                    const idx = context.dataIndex;
                                    const dsIdx = context.datasetIndex;
                                    // For stacked LDES charge, subtract battery charge to get LDES-only contribution
                                    const prevDs = dsIdx > 0 ? compressedDayChart.data.datasets[dsIdx - 1] : null;
                                    const isStackedOnCharge = prevDs && prevDs._isCharge;
                                    const val = Math.abs(context.parsed.y);
                                    const prev = isStackedOnCharge ? Math.abs(prevDs.data?.[idx] || 0) : 0;
                                    const contrib = isStackedOnCharge ? val - prev : val;
                                    if (contrib < 1) return null;
                                    return ` ${ds.label}: ${fmtMW(contrib)}`;
                                }
                                // For curtailed datasets, use stashed surplus values
                                if (ds._surplusVals) {
                                    const sv = ds._surplusVals[context.dataIndex];
                                    if (sv < 1) return null;
                                    return ` ${ds.label}: ${fmtMW(sv)}`;
                                }
                                // For stacked matched, show individual contribution
                                const idx = context.dataIndex;
                                const dsIdx = context.datasetIndex;
                                const val = context.parsed.y;
                                const prev = dsIdx > 0 ? compressedDayChart.data.datasets[dsIdx - 1].data[idx] : 0;
                                const contribution = val - prev;
                                if (contribution < 1) return null;
                                return ` ${ds.label}: ${fmtMW(contribution)}`;
                            }
                        }
                    }
                }
            }
        });
    }
}

// ---- Peak Capacity Visual ----
function updatePeakCapacity(entry, region) {
    const container = document.getElementById('peakCapacityVisual');
    if (!container) return;

    const peakGapPct = entry.peak_gap_pct || 0;
    const peakDemandMW = region.peak_demand_mw || 0;
    const gapMW = Math.round(peakDemandMW * peakGapPct / 100);
    const coveredMW = peakDemandMW - gapMW;
    const procPct = entry.procurement_pct || 0;

    // Bar heights proportional to MW
    const maxBarH = 150;
    const demandH = maxBarH;
    const coveredH = peakDemandMW > 0 ? Math.max(8, (coveredMW / peakDemandMW) * maxBarH) : 8;
    const gapH = peakDemandMW > 0 ? Math.max(4, (gapMW / peakDemandMW) * maxBarH) : 4;

    container.innerHTML = `
        <div class="peak-capacity-note">
            At <strong style="color:#0EA5E9;">${procPct}%</strong> procurement and
            <strong style="color:#0EA5E9;">${document.getElementById('thresholdSelect').value}%</strong> hourly match across the year,
            the worst single hour still needs
            <strong style="color:#EF4444;">${formatPct(peakGapPct)}</strong> of peak demand from backup sources.
        </div>
        <div class="peak-tower-wrap">
            <div class="peak-tower">
                <div class="peak-tower-value" style="color:#F59E0B;">${formatCommas(peakDemandMW)} MW</div>
                <div class="peak-tower-bar" style="height:${demandH}px; background: rgba(245,158,11,0.4); border: 2px solid #F59E0B;"></div>
                <div class="peak-tower-label">Peak<br>Demand</div>
            </div>
            <div class="peak-tower">
                <div class="peak-tower-value" style="color:#0EA5E9;">${formatCommas(coveredMW)} MW</div>
                <div class="peak-tower-bar" style="height:${coveredH}px; background: rgba(14,165,233,0.4); border: 2px solid #0EA5E9;"></div>
                <div class="peak-tower-label">Clean<br>Coverage</div>
            </div>
            <div class="peak-tower">
                <div class="peak-tower-value" style="color:#EF4444;">${formatCommas(gapMW)} MW</div>
                <div class="peak-tower-bar" style="height:${gapH}px; background: rgba(239,68,68,0.4); border: 2px solid #EF4444;"></div>
                <div class="peak-tower-label">Backup<br>Needed</div>
            </div>
        </div>
    `;
}

// ---- Cost Panel ----
function updateCostPanel(entry) {
    const content = document.getElementById('costContent');
    const costs = entry.costs;
    const iso = document.getElementById('regionSelect').value;

    if (!costs || !costs.resource_costs) {
        content.innerHTML = `
            <div class="cost-unavailable">
                Cost breakdown data is not available for this configuration.
                Cost modeling requires <code>regional_lcoe</code> and <code>grid_mix_shares</code> in the config.
            </div>
        `;
        return;
    }

    const adj = cfAdjust(entry, iso);
    const rc = costs.resource_costs;
    // Generation resources then storage types
    const genResources = ['clean_firm', 'ccs_ccgt', 'solar', 'wind', 'hydro'];
    const storageResources = ['battery', 'ldes'];

    let rows = '';
    genResources.forEach(r => {
        const d = rc[r];
        if (!d) return;
        // CCS has different field names
        const totalPct = d.total_pct_of_demand ?? (d.new_share != null ? Math.round((d.existing_share || 0) + (d.new_share || 0)) : null);
        const existPct = d.existing_pct ?? (d.existing_share != null ? Math.round(d.existing_share) : null);
        const newPct = d.new_pct ?? (d.new_share != null ? Math.round(d.new_share) : null);
        const costVal = d.cost_per_demand_mwh ?? d.cost ?? null;
        const displayCost = r === 'clean_firm' ? adj.newCfCostPerMwh : costVal;
        const isCfAdjusted = r === 'clean_firm' && selectedCfCost !== 90;
        rows += `
            <tr>
                <td><span class="resource-dot" style="background:${COLORS[r].alpha}"></span>${RESOURCE_LABELS[r]}</td>
                <td>${totalPct != null ? Math.round(totalPct) + '%' : '--'}</td>
                <td>${existPct != null ? Math.round(existPct) + '%' : '--'}</td>
                <td>${newPct != null ? Math.round(newPct) + '%' : '--'}</td>
                <td${isCfAdjusted ? ' style="color:#D97706;font-weight:600;"' : ''}>${displayCost != null ? '$' + formatNum(displayCost) : '--'}${isCfAdjusted ? '*' : ''}</td>
            </tr>`;
    });

    storageResources.forEach(r => {
        const d = rc[r];
        if (!d) return;
        const color = COLORS[r] ? COLORS[r].alpha : COLORS.storage.alpha;
        const label = RESOURCE_LABELS[r] || r;
        rows += `
            <tr>
                <td><span class="resource-dot" style="background:${color}"></span>${label}</td>
                <td colspan="3" style="text-align:center;color:var(--text-muted);font-style:italic;">
                    ${d.dispatch_pct != null ? d.dispatch_pct + '% dispatch' : '--'}
                </td>
                <td>${d.cost_per_demand_mwh != null ? '$' + formatNum(d.cost_per_demand_mwh) : '--'}</td>
            </tr>`;
    });

    const cfNote = selectedCfCost !== 90 ? `<div class="cost-note" style="color:#D97706;">* Clean firm cost adjusted from $90/MWh to $${selectedCfCost}/MWh. New-build portion: ${formatNum(rc.clean_firm?.new_pct || 0)}% of demand &times; $${selectedCfCost}/MWh LCOE. Delta: +$${formatNum(adj.totalDelta)}/MWh.</div>` : '';

    content.innerHTML = `
        <div class="cost-table-wrapper">
            <table class="cost-table">
                <thead>
                    <tr>
                        <th>Resource</th>
                        <th>Total (% of Demand)</th>
                        <th>Existing Grid</th>
                        <th>New Build</th>
                        <th>Cost ($/MWh)</th>
                    </tr>
                </thead>
                <tbody>
                    ${rows}
                    <tr class="row-total">
                        <td>Total Blended Cost</td>
                        <td colspan="3"></td>
                        <td${selectedCfCost !== 90 ? ' style="color:#D97706;"' : ''}>${'$' + formatNum(adj.newTotal)}/MWh</td>
                    </tr>
                    ${costs.effective_cost_per_useful_mwh != null ? `
                    <tr class="row-total">
                        <td>Effective Cost (adj. for curtailment)</td>
                        <td colspan="3"></td>
                        <td${selectedCfCost !== 90 ? ' style="color:#D97706;"' : ''}>$${formatNum(adj.newEffective)}/MWh</td>
                    </tr>` : ''}
                </tbody>
            </table>
        </div>
        ${cfNote}
        ${costs.curtailment_pct != null && costs.curtailment_pct > 0 ? `
        <div class="cost-note">
            Curtailment (${formatNum(costs.curtailment_pct)}%) inflates effective cost above blended cost.
        </div>` : ''}
    `;
}

// ---- Narrative Stats ----
// ---- Curtailment Visualization (dynamic from data) ----
function populateCurtailmentVisual() {
    const container = document.getElementById('curtailmentVisual');
    if (!container || !DATA) return;
    const isos = Object.keys(DATA.results);
    const thresholds = ['75', '85', '95', '99', '100'];
    const thresholdLabels = ['75%', '85%', '95%', '99%', '100%'];
    let html = '';
    for (let ti = 0; ti < thresholds.length; ti++) {
        const tk = thresholds[ti];
        let curtSum = 0, matchSum = 0, count = 0;
        for (const iso of isos) {
            const region = DATA.results[iso];
            const t = region ? resolveEntry(region, tk) : null;
            if (t) {
                const curt = t.costs?.curtailment_pct || Math.max(0, t.procurement_pct - 100);
                const match = t.hourly_match_score || 0;
                curtSum += curt;
                matchSum += match;
                count++;
            }
        }
        if (count > 0) {
            const avgCurt = Math.round(curtSum / count);
            const avgMatch = Math.round(matchSum / count);
            const matchH = Math.min(75, avgMatch * 0.75);
            const curtH = Math.min(25, avgCurt * 0.5);
            html += `<div class="curtail-bar-group">
                <div class="curtail-bar-label">${thresholdLabels[ti]}</div>
                <div class="curtail-bar-stack">
                    <div class="curtail-bar-fill" style="height:${curtH}%; background:rgba(239,68,68,0.4);"></div>
                    <div class="curtail-bar-fill" style="height:${matchH}%; background:rgba(14,165,233,0.4);"></div>
                </div>
                <div class="curtail-bar-value">~${avgCurt}%</div>
                <div class="curtail-bar-sub">curtailed</div>
            </div>`;
        }
    }
    if (html) container.innerHTML = html;
}

// ---- Reliability Gauges (dynamic from data) ----
function populateReliabilityGauges() {
    const container = document.getElementById('reliabilityGauges');
    if (!container || !DATA) return;
    const isos = Object.keys(DATA.results);
    const gaugeColors = ['#0EA5E9', '#22C55E', '#F59E0B', '#EF4444', '#1A2744'];
    const circumference = 2 * Math.PI * 38; // ~238.76
    let html = '';
    for (let i = 0; i < isos.length; i++) {
        const iso = isos[i];
        const reg99 = DATA.results[iso];
        const t99 = reg99 ? resolveEntry(reg99, '99') : null;
        if (!t99) continue;
        const peakGapPct = t99.peak_gap_pct || 0;
        const coveragePct = Math.round(100 - peakGapPct);
        const color = gaugeColors[i % gaugeColors.length];
        const dashoffset = circumference * (1 - coveragePct / 100);
        html += `<div class="reliability-gauge">
            <div class="gauge-ring">
                <svg width="90" height="90" viewBox="0 0 90 90">
                    <circle cx="45" cy="45" r="38" fill="none" stroke="rgba(209,213,219,0.4)" stroke-width="6"/>
                    <circle cx="45" cy="45" r="38" fill="none" stroke="${color}" stroke-width="6" stroke-dasharray="${circumference.toFixed(0)}" stroke-dashoffset="${dashoffset.toFixed(0)}" stroke-linecap="round"/>
                </svg>
                <div class="gauge-ring-label">${coveragePct}%</div>
            </div>
            <div class="gauge-name">${iso}</div>
        </div>`;
    }
    if (html) container.innerHTML = html;
}

function getAvgAdjustedCost(thresholdKey) {
    if (!DATA) return 0;
    const isos = Object.keys(DATA.results);
    let sum = 0, count = 0;
    for (const iso of isos) {
        const cost = getAdjustedEffectiveCost(iso, thresholdKey);
        if (cost != null) { sum += cost; count++; }
    }
    return count > 0 ? sum / count : 0;
}

function populateNarrativeStats() {
    refreshNarrativeStats();
}

function refreshNarrativeStats() {
    const container = document.getElementById('narrativeCostStats');
    if (!container || !DATA) return;

    const isos = Object.keys(DATA.results);

    const avgCost75 = getAvgAdjustedCost('75');
    const avgCost90 = getAvgAdjustedCost('90');
    const avgCost99 = getAvgAdjustedCost('99');
    const avgCost100 = getAvgAdjustedCost('100');
    const has100 = avgCost100 > 0;
    const fullMultiplier = has100 ? (avgCost100 / avgCost75) : (avgCost99 / avgCost75);
    const cfTag = selectedCfCost !== 90 ? ` <span style="font-size:0.72rem;color:#D97706;">(CF@$${selectedCfCost})</span>` : '';

    container.innerHTML = `
        <div class="story-stat-card">
            <div class="story-stat-label">75% Match Cost</div>
            <div class="story-stat-value" style="color:#7A8B5C;">$${avgCost75.toFixed(0)}</div>
            <div class="story-stat-sub">avg $/MWh across ISOs${cfTag}</div>
        </div>
        <div class="story-stat-card">
            <div class="story-stat-label">99% Match Cost</div>
            <div class="story-stat-value" style="color:#C75B4A;">$${avgCost99.toFixed(0)}</div>
            <div class="story-stat-sub">avg $/MWh across ISOs${cfTag}</div>
        </div>
        ${has100 ? `
        <div class="story-stat-card">
            <div class="story-stat-label">100% Match Cost</div>
            <div class="story-stat-value" style="color:#C75B4A;">$${avgCost100.toFixed(0)}</div>
            <div class="story-stat-sub">avg $/MWh across ISOs${cfTag}</div>
        </div>` : `
        <div class="story-stat-card">
            <div class="story-stat-label">Cost Multiplier</div>
            <div class="story-stat-value">${(avgCost99 / avgCost75).toFixed(1)}x</div>
            <div class="story-stat-sub">99% vs 75% cost ratio</div>
        </div>`}
        <div class="story-stat-card">
            <div class="story-stat-label">Cost Multiplier</div>
            <div class="story-stat-value" style="color:var(--navy);">${fullMultiplier.toFixed(1)}x</div>
            <div class="story-stat-sub">${has100 ? '100%' : '99%'} vs 75% cost ratio</div>
        </div>
    `;

    // Populate step card inline cost values
    const el75 = document.getElementById('stepCost75');
    const el90 = document.getElementById('stepCost90');
    const el99 = document.getElementById('stepCost99');
    if (el75) el75.textContent = `$${avgCost75.toFixed(0)}/MWh avg`;
    if (el90 && avgCost90 > 0) el90.textContent = `$${avgCost90.toFixed(0)}/MWh avg`;
    if (el99) el99.textContent = `$${avgCost99.toFixed(0)}/MWh avg`;

    // Populate intro multiplier
    const introMult = document.getElementById('introMultiplier');
    if (introMult) introMult.textContent = `${fullMultiplier.toFixed(1)}x`;
}

// ---- Narrative Mix Evolution Chart (with region toggle) ----
let narrativeMixChart = null;
let currentMixRegion = 'average';

const MIX_RESOURCES = ['clean_firm', 'solar', 'wind', 'hydro', 'storage'];
const MIX_LABELS_MAP = { clean_firm: 'Clean Firm', solar: 'Solar', wind: 'Wind', hydro: 'Hydro', storage: 'Storage' };
const MIX_COLORS = {
    solar:      { fill: 'rgba(245,158,11,0.50)',  border: '#F59E0B' },
    wind:       { fill: 'rgba(34,197,94,0.50)',  border: '#22C55E' },
    hydro:      { fill: 'rgba(14,165,233,0.50)',  border: '#0EA5E9' },
    clean_firm: { fill: 'rgba(26,39,68,0.50)',    border: '#1A2744' },
    storage:    { fill: 'rgba(239,68,68,0.50)',   border: '#EF4444' }
};

const MIX_REGION_INSIGHTS = {
    average: '<strong>Regional Variation:</strong> Wind-rich ERCOT sustains wind-heavy mixes to 95%+, while PJM and NEISO require a pivot to nuclear/clean firm at lower thresholds.',
    CAISO: '<strong>CAISO (California):</strong> Leverages strong solar (35% at 75%) and high hydro cap (30%). Clean firm rises from 10% to 43% at 100%. Solar stays relevant throughout due to excellent irradiance.',
    ERCOT: '<strong>ERCOT (Texas):</strong> Wind dominates at 65% through 95% matching thanks to $40/MWh wind LCOE. The 95%â†’100% transition is the most dramatic of any region: clean firm surges +49pp while wind drops 40pp.',
    PJM: '<strong>PJM (Mid-Atlantic):</strong> Existing 32% nuclear fleet provides a massive head start. The mix holds steady from 75% to 90%, then jumps to 60% clean firm at 95%. PJM reaches 68% clean firm at 100%.',
    NYISO: '<strong>NYISO (New York):</strong> Hydro stays locked at 40% across all targets. Uses zero solar until 100%. The simplest mix â€” essentially clean firm + hydro + wind â€” reflects the region\'s unique resource endowment.',
    NEISO: '<strong>NEISO (New England):</strong> The most expensive region shows the sharpest shift. Clean firm reaches 78% at 100% â€” the highest of any region. Hydro drops from 30% to 16% and wind is eliminated entirely at 100%.'
};

function getMixDataForRegion(region) {
    const thresholdKeys = ['75', '80', '85', '90', '95', '99', '100'];
    const isos = Object.keys(DATA.results);
    const labels = [];
    const existingData = {};
    const newData = {};
    MIX_RESOURCES.forEach(r => { existingData[r] = []; newData[r] = []; });
    const curtailmentData = [];
    const procurementData = [];

    for (const tk of thresholdKeys) {
        const avgExisting = {};
        const avgNew = {};
        MIX_RESOURCES.forEach(r => { avgExisting[r] = 0; avgNew[r] = 0; });
        let avgCurtailment = 0;
        let avgProcurement = 0;
        let count = 0;

        const regions = region === 'average' ? isos : [region];
        for (const iso of regions) {
            const reg = DATA.results[iso];
            const t = reg ? resolveEntry(reg, tk) : null;
            if (!t) continue;
            const rc = t.costs?.resource_costs;
            if (!rc) continue;

            MIX_RESOURCES.forEach(r => {
                if (r === 'storage') {
                    avgNew[r] += (rc.storage?.dispatch_pct || 0);
                } else {
                    avgExisting[r] += (rc[r]?.existing_pct || 0);
                    avgNew[r] += (rc[r]?.new_pct || 0);
                }
            });
            const curtailAsDemand = (t.procurement_pct || 0) * (t.costs?.curtailment_pct || 0) / 100;
            avgCurtailment += curtailAsDemand;
            avgProcurement += (t.procurement_pct || 0);
            count++;
        }

        if (count > 0) {
            labels.push(tk + '%');
            MIX_RESOURCES.forEach(r => {
                existingData[r].push(Math.round(avgExisting[r] / count * 10) / 10);
                newData[r].push(Math.round(avgNew[r] / count * 10) / 10);
            });
            curtailmentData.push(Math.round(avgCurtailment / count * 10) / 10);
            procurementData.push(Math.round(avgProcurement / count * 10) / 10);
        }
    }
    return { labels, existingData, newData, curtailmentData, procurementData };
}

// Crosshatch curtailment overlay plugin
const curtailmentOverlayPlugin = {
    id: 'curtailmentOverlay',
    afterDatasetsDraw(chart) {
        const curtailArr = chart._curtailmentData;
        const procArr = chart._procurementData;
        if (!curtailArr || !procArr) return;

        const ctx = chart.ctx;
        const yScale = chart.scales.y;
        // Get bar geometry from first visible dataset
        let refMeta = null;
        for (let d = 0; d < chart.data.datasets.length; d++) {
            if (chart.isDatasetVisible(d)) { refMeta = chart.getDatasetMeta(d); break; }
        }
        if (!refMeta || refMeta.data.length === 0) return;

        for (let i = 0; i < chart.data.labels.length; i++) {
            const curtailAmt = curtailArr[i] || 0;
            if (curtailAmt <= 0) continue;
            const totalProc = procArr[i];
            const usefulEnd = totalProc - curtailAmt;

            const bar = refMeta.data[i];
            const barHW = bar.width / 2;
            const xL = bar.x - barHW;
            const yTop = yScale.getPixelForValue(totalProc);
            const yBot = yScale.getPixelForValue(usefulEnd);
            const w = bar.width;
            const h = yBot - yTop;
            if (h <= 0) continue;

            ctx.save();
            ctx.beginPath();
            ctx.rect(xL, yTop, w, h);
            ctx.clip();
            // White wash
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.fillRect(xL, yTop, w, h);
            // Diagonal lines
            ctx.strokeStyle = 'rgba(26,39,68,0.45)';
            ctx.lineWidth = 1.3;
            const step = 6;
            const diag = w + h;
            for (let d = 0; d < diag; d += step) {
                ctx.beginPath();
                ctx.moveTo(xL + d, yTop);
                ctx.lineTo(xL + d - h, yTop + h);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
};

// Existing/new boundary plugin â€” draws subtle dashed line at existing/new boundary
const existingBoundaryPlugin = {
    id: 'existingBoundary',
    afterDatasetsDraw(chart) {
        const boundaryMap = chart._existingBoundary;
        if (!boundaryMap) return;
        const ctx = chart.ctx;
        const yScale = chart.scales.y;
        // boundaryMap: array of { existingTop: cumulative existing total at each bar index }
        let refMeta = null;
        for (let d = 0; d < chart.data.datasets.length; d++) {
            if (chart.isDatasetVisible(d)) { refMeta = chart.getDatasetMeta(d); break; }
        }
        if (!refMeta || refMeta.data.length === 0) return;

        for (let i = 0; i < boundaryMap.length; i++) {
            const existTop = boundaryMap[i];
            if (existTop <= 0) continue;
            const bar = refMeta.data[i];
            const barHW = bar.width / 2;
            const yPx = yScale.getPixelForValue(existTop);
            ctx.save();
            ctx.setLineDash([4, 3]);
            ctx.strokeStyle = 'rgba(255,255,255,0.7)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(bar.x - barHW + 2, yPx);
            ctx.lineTo(bar.x + barHW - 2, yPx);
            ctx.stroke();
            ctx.restore();
        }
    }
};

function buildMixDatasets(data) {
    const { existingData, newData } = data;
    // Stack order (bottom to top): existing resources, then new resources
    // Existing: clean_firm, hydro, wind, solar (bottom)
    // New: solar, wind, hydro, storage, clean_firm (top â€” so curtailment hits new first)
    const EXISTING_ORDER = ['clean_firm', 'hydro', 'wind', 'solar'];
    const NEW_ORDER = ['solar', 'wind', 'hydro', 'storage', 'clean_firm'];

    const existingAlpha = 0.75;
    const newAlpha = 0.45;
    const datasets = [];

    for (const r of EXISTING_ORDER) {
        const c = MIX_COLORS[r];
        datasets.push({
            label: MIX_LABELS_MAP[r] + ' (existing)',
            data: existingData[r],
            backgroundColor: c.fill.replace(/[\d.]+\)$/, existingAlpha + ')'),
            borderColor: c.border,
            borderWidth: 1.5,
            borderRadius: 6,
            stack: 'mix',
            _resourceKey: r,
            _isExisting: true,
        });
    }
    for (const r of NEW_ORDER) {
        const c = MIX_COLORS[r];
        datasets.push({
            label: MIX_LABELS_MAP[r] + ' (new)',
            data: newData[r],
            backgroundColor: c.fill.replace(/[\d.]+\)$/, newAlpha + ')'),
            borderColor: c.border,
            borderWidth: 1,
            borderRadius: 6,
            borderSkipped: 'start',
            stack: 'mix',
            _resourceKey: r,
            _isExisting: false,
        });
    }
    return datasets;
}

function initNarrativeMixChart() {
    const canvas = document.getElementById('narrativeMixChart');
    if (!canvas || !DATA) return;

    const data = getMixDataForRegion('average');
    if (data.labels.length === 0) return;

    const datasets = buildMixDatasets(data);
    const maxProc = Math.max(...data.procurementData);
    const yMax = Math.ceil(maxProc / 10) * 10 + 10;

    // Calculate existing boundary line positions
    const existingBoundary = data.labels.map((_, i) => {
        let total = 0;
        MIX_RESOURCES.forEach(r => { total += data.existingData[r][i]; });
        return total;
    });

    const ctx = canvas.getContext('2d');
    narrativeMixChart = new Chart(ctx, {
        type: 'bar',
        data: { labels: data.labels, datasets },
        plugins: [ChartDataLabels, curtailmentOverlayPlugin, existingBoundaryPlugin],
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 800, easing: 'easeOutCubic' },
            layout: { padding: { top: 8, right: 8, bottom: 4, left: 4 } },
            plugins: {
                legend: {
                    display: true,
                    position: 'bottom',
                    labels: {
                        usePointStyle: true,
                        pointStyle: 'rectRounded',
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11 },
                        color: '#1A1A1A',
                        padding: 14,
                        generateLabels: function(chart) {
                            // Merge existing+new into one legend entry per resource
                            const items = MIX_RESOURCES.map(r => {
                                const c = MIX_COLORS[r];
                                return {
                                    text: MIX_LABELS_MAP[r],
                                    fillStyle: c.fill,
                                    strokeStyle: c.border,
                                    lineWidth: 2,
                                    hidden: false,
                                    pointStyle: 'rectRounded',
                                };
                            });
                            // Add curtailment legend entry
                            items.push({
                                text: 'Curtailment',
                                fillStyle: 'rgba(26,39,68,0.12)',
                                strokeStyle: 'rgba(26,39,68,0.45)',
                                lineWidth: 2,
                                pointStyle: 'line',
                                lineDash: [3,2],
                                hidden: false,
                            });
                            return items;
                        }
                    },
                    onClick: () => {} // disable toggle
                },
                tooltip: {
                    backgroundColor: 'rgba(26,39,68,0.92)',
                    titleFont: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 13, weight: 600 },
                    bodyFont: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12 },
                    padding: 12,
                    cornerRadius: 8,
                    filter: function(tooltipItem) {
                        return tooltipItem.parsed.y > 0;
                    },
                    callbacks: {
                        title: function(items) {
                            if (!items.length) return '';
                            const idx = items[0].dataIndex;
                            const proc = narrativeMixChart._procurementData[idx];
                            const curtail = narrativeMixChart._curtailmentData[idx];
                            return items[0].label + '  (procure ' + Math.round(proc) + '% of demand, curtail ' + Math.round(curtail) + '%)';
                        },
                        label: function(context) {
                            return ` ${context.dataset.label}: ${context.parsed.y.toFixed(1)}% of demand`;
                        }
                    }
                },
                datalabels: {
                    display: function(context) {
                        return context.dataset.data[context.dataIndex] >= 6;
                    },
                    color: function(context) {
                        if (context.dataset._resourceKey === 'clean_firm') return '#FFFFFF';
                        return '#1A1A1A';
                    },
                    font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 10, weight: 700 },
                    formatter: function(value) {
                        return Math.round(value) + '%';
                    },
                    anchor: 'center',
                    align: 'center',
                },
                annotation: {
                    annotations: {
                        demandLine: {
                            type: 'line',
                            yMin: 100,
                            yMax: 100,
                            borderColor: 'rgba(26,39,68,0.6)',
                            borderWidth: 2,
                            borderDash: [6, 4],
                            label: {
                                display: true,
                                content: '100% of demand',
                                position: 'end',
                                backgroundColor: 'rgba(26,39,68,0.75)',
                                color: '#fff',
                                font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11, weight: 600 },
                                padding: { x: 6, y: 3 },
                                borderRadius: 4,
                            }
                        }
                    }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    title: {
                        display: true,
                        text: 'Hourly Matching Target',
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12, weight: 600 },
                        color: '#4A4540',
                    },
                    grid: { display: false }, border: { display: true, color: '#D4D8E0' },
                    ticks: {
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11 },
                        color: '#6B6356',
                    }
                },
                y: {
                    stacked: true,
                    max: yMax,
                    title: {
                        display: true,
                        text: 'Procurement (% of demand)',
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12, weight: 600 },
                        color: '#4A4540',
                    },
                    grid: { display: false }, border: { display: true, color: '#D4D8E0' },
                    ticks: {
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11 },
                        color: '#6B6356',
                        callback: (v) => v + '%',
                    }
                }
            }
        }
    });

    // Attach custom data for plugins
    narrativeMixChart._curtailmentData = data.curtailmentData;
    narrativeMixChart._procurementData = data.procurementData;
    narrativeMixChart._existingBoundary = existingBoundary;

    // Bind region toggle buttons
    const toggleRow = document.getElementById('mixRegionToggle');
    if (toggleRow) {
        toggleRow.addEventListener('click', function(e) {
            const btn = e.target.closest('.region-toggle-btn');
            if (!btn) return;
            const region = btn.dataset.region;
            toggleRow.querySelectorAll('.region-toggle-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            updateMixChartRegion(region);
        });
    }
}

function updateMixChartRegion(region) {
    if (!narrativeMixChart || !DATA) return;
    currentMixRegion = region;
    const data = getMixDataForRegion(region);
    narrativeMixChart.data.labels = data.labels;

    const newDatasets = buildMixDatasets(data);
    newDatasets.forEach((ds, i) => {
        narrativeMixChart.data.datasets[i].data = ds.data;
    });

    // Update plugin data
    narrativeMixChart._curtailmentData = data.curtailmentData;
    narrativeMixChart._procurementData = data.procurementData;
    const existingBoundary = data.labels.map((_, i) => {
        let total = 0;
        MIX_RESOURCES.forEach(r => { total += data.existingData[r][i]; });
        return total;
    });
    narrativeMixChart._existingBoundary = existingBoundary;

    // Update y-axis max
    const maxProc = Math.max(...data.procurementData);
    narrativeMixChart.options.scales.y.max = Math.ceil(maxProc / 10) * 10 + 10;

    narrativeMixChart.update();

    const insightEl = document.getElementById('mixRegionInsight');
    if (insightEl && MIX_REGION_INSIGHTS[region]) {
        insightEl.innerHTML = MIX_REGION_INSIGHTS[region];
    }
}

// ---- Incremental Resources Chart â€” existing vs new at each target ----
let incrementalMixChart = null;
let currentIncrementalRegion = 'CAISO';

const INCREMENTAL_INSIGHTS = {
    CAISO: '<strong>CAISO:</strong> Starts with 48.5% existing clean (solar-heavy). New build is modest through 90%, then accelerates sharply â€” at 100%, new clean firm alone exceeds 53% of demand, more than all existing clean combined.',
    ERCOT: '<strong>ERCOT:</strong> Only 46.1% existing clean, mostly wind. New wind additions drive early targets cheaply. But at 100%, new clean firm (47%) dwarfs the entire existing fleet â€” a near-complete rebuild of the generation stack.',
    PJM: '<strong>PJM:</strong> The 32% existing nuclear fleet gives PJM a massive head start. New build stays minimal through 90% â€” then jumps as clean firm additions pile on. Even so, PJM needs less new build at 100% than most regions.',
    NYISO: '<strong>NYISO:</strong> Existing hydro (16%) and nuclear (18%) cover early targets efficiently. New build stays modest through 95%, then explodes at 100% with +34% new hydro and +54% new clean firm â€” the sharpest final step.',
    NEISO: '<strong>NEISO:</strong> Starts with 33.5% existing clean but it\'s spread thin across resources. New clean firm dominates at every target level, reaching 65% of demand at 100% â€” the highest new-build intensity of any region.'
};

function getIncrementalData(region) {
    const thresholdKeys = ['75', '80', '85', '90', '95', '99', '100'];
    const labels = [];
    const existingData = {};
    const newData = {};
    MIX_RESOURCES.forEach(r => { existingData[r] = []; newData[r] = []; });
    let existingCleanTotal = 0;

    // Get total existing clean for the region
    const gridMix = DATA.config?.grid_mix_shares?.[region];
    if (gridMix) {
        existingCleanTotal = Object.values(gridMix).reduce((s, v) => s + v, 0);
    }

    for (const tk of thresholdKeys) {
        const reg = DATA.results[region];
        const t = reg ? resolveEntry(reg, tk) : null;
        if (!t) continue;
        const rc = t.costs?.resource_costs;
        if (!rc) continue;

        labels.push(tk + '%');
        MIX_RESOURCES.forEach(r => {
            if (r === 'storage') {
                existingData[r].push(0);
                newData[r].push(rc.storage?.dispatch_pct || 0);
            } else {
                existingData[r].push(rc[r]?.existing_pct || 0);
                newData[r].push(rc[r]?.new_pct || 0);
            }
        });
    }
    return { labels, existingData, newData, existingCleanTotal };
}

function buildIncrementalDatasets(data) {
    const { existingData, newData } = data;
    const EXISTING_ORDER = ['clean_firm', 'hydro', 'wind', 'solar'];
    const NEW_ORDER = ['solar', 'wind', 'hydro', 'storage', 'clean_firm'];
    const existingAlpha = 0.75;
    const newAlpha = 0.40;
    const datasets = [];

    for (const r of EXISTING_ORDER) {
        const c = MIX_COLORS[r];
        datasets.push({
            label: MIX_LABELS_MAP[r] + ' (existing)',
            data: existingData[r],
            backgroundColor: c.fill.replace(/[\d.]+\)$/, existingAlpha + ')'),
            borderColor: c.border,
            borderWidth: 1.5,
            borderRadius: 6,
            stack: 'incr',
            _resourceKey: r,
            _isExisting: true,
        });
    }
    for (const r of NEW_ORDER) {
        const c = MIX_COLORS[r];
        datasets.push({
            label: MIX_LABELS_MAP[r] + ' (new)',
            data: newData[r],
            backgroundColor: c.fill.replace(/[\d.]+\)$/, newAlpha + ')'),
            borderColor: c.border,
            borderWidth: 1,
            borderRadius: 6,
            borderSkipped: 'start',
            stack: 'incr',
            _resourceKey: r,
            _isExisting: false,
        });
    }
    return datasets;
}

function initIncrementalMixChart() {
    const canvas = document.getElementById('incrementalMixChart');
    if (!canvas || !DATA) return;

    const data = getIncrementalData('CAISO');
    if (data.labels.length === 0) return;

    const datasets = buildIncrementalDatasets(data);

    // Compute max for y-axis
    const maxTotal = data.labels.map((_, i) => {
        let sum = 0;
        MIX_RESOURCES.forEach(r => { sum += data.existingData[r][i] + data.newData[r][i]; });
        return sum;
    });
    const yMax = Math.ceil(Math.max(...maxTotal) / 10) * 10 + 10;

    const ctx = canvas.getContext('2d');
    incrementalMixChart = new Chart(ctx, {
        type: 'bar',
        data: { labels: data.labels, datasets },
        plugins: [ChartDataLabels, existingBoundaryPlugin],
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 600, easing: 'easeOutCubic' },
            layout: { padding: { top: 12, right: 8, bottom: 4, left: 4 } },
            plugins: {
                legend: {
                    display: true,
                    position: 'bottom',
                    labels: {
                        usePointStyle: true,
                        pointStyle: 'rectRounded',
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11 },
                        color: '#1A1A1A',
                        padding: 14,
                        generateLabels: function(chart) {
                            const items = MIX_RESOURCES.map(r => ({
                                text: MIX_LABELS_MAP[r],
                                fillStyle: MIX_COLORS[r].fill,
                                strokeStyle: MIX_COLORS[r].border,
                                lineWidth: 2,
                                hidden: false,
                                pointStyle: 'rectRounded',
                            }));
                            items.push({
                                text: 'Saturated = Existing',
                                fillStyle: 'rgba(100,100,100,0.75)',
                                strokeStyle: '#666',
                                lineWidth: 2,
                                pointStyle: 'rectRounded',
                            });
                            items.push({
                                text: 'Faded = New Build',
                                fillStyle: 'rgba(100,100,100,0.35)',
                                strokeStyle: '#999',
                                lineWidth: 2,
                                pointStyle: 'rectRounded',
                            });
                            return items;
                        }
                    },
                    onClick: () => {}
                },
                tooltip: {
                    backgroundColor: 'rgba(26,39,68,0.92)',
                    titleFont: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 13, weight: 600 },
                    bodyFont: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12 },
                    padding: 12,
                    cornerRadius: 8,
                    filter: function(tooltipItem) { return tooltipItem.parsed.y > 0; },
                    callbacks: {
                        title: function(items) {
                            if (!items.length) return '';
                            const idx = items[0].dataIndex;
                            let totalNew = 0;
                            MIX_RESOURCES.forEach(r => {
                                totalNew += incrementalMixChart._incrNewData[r][idx] || 0;
                            });
                            return items[0].label + ' target  (new build: ' + Math.round(totalNew) + '% of demand)';
                        },
                        label: function(context) {
                            return ` ${context.dataset.label}: ${context.parsed.y.toFixed(1)}% of demand`;
                        }
                    }
                },
                datalabels: {
                    display: function(context) {
                        return context.dataset.data[context.dataIndex] >= 5;
                    },
                    color: function(context) {
                        if (context.dataset._resourceKey === 'clean_firm') return '#FFFFFF';
                        return '#1A1A1A';
                    },
                    font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 10, weight: 700 },
                    formatter: function(value) {
                        return Math.round(value) + '%';
                    },
                    anchor: 'center',
                    align: 'center',
                },
                annotation: {
                    annotations: {
                        existingLine: {
                            type: 'line',
                            yMin: data.existingCleanTotal,
                            yMax: data.existingCleanTotal,
                            borderColor: 'rgba(26,39,68,0.5)',
                            borderWidth: 2,
                            borderDash: [6, 4],
                            label: {
                                display: true,
                                content: 'Current grid clean: ' + Math.round(data.existingCleanTotal) + '%',
                                position: 'start',
                                backgroundColor: 'rgba(26,39,68,0.75)',
                                color: '#fff',
                                font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11, weight: 600 },
                                padding: { x: 6, y: 3 },
                                borderRadius: 4,
                            }
                        }
                    }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    title: {
                        display: true,
                        text: 'Hourly Matching Target',
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12, weight: 600 },
                        color: '#4A4540',
                    },
                    grid: { display: false }, border: { display: true, color: '#D4D8E0' },
                    ticks: {
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12, weight: 600 },
                        color: '#1A2744',
                    }
                },
                y: {
                    stacked: true,
                    max: yMax,
                    title: {
                        display: true,
                        text: 'Resources (% of demand)',
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12, weight: 600 },
                        color: '#4A4540',
                    },
                    grid: { display: false }, border: { display: true, color: '#D4D8E0' },
                    ticks: {
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11 },
                        color: '#6B6356',
                        callback: (v) => v + '%',
                    }
                }
            }
        }
    });

    // Attach data for tooltip
    incrementalMixChart._incrNewData = data.newData;
    // Attach existing boundary for plugin
    incrementalMixChart._existingBoundary = data.labels.map((_, i) => {
        let total = 0;
        MIX_RESOURCES.forEach(r => { total += data.existingData[r][i]; });
        return total;
    });

    // Set initial insight
    const insightEl = document.getElementById('incrementalInsight');
    if (insightEl) insightEl.innerHTML = INCREMENTAL_INSIGHTS['CAISO'];

    // Bind region pills
    const pillRow = document.getElementById('incrementalRegionPills');
    if (pillRow) {
        pillRow.addEventListener('click', function(e) {
            const pill = e.target.closest('.incremental-pill');
            if (!pill) return;
            const region = pill.dataset.region;
            pillRow.querySelectorAll('.incremental-pill').forEach(p => p.classList.remove('active'));
            pill.classList.add('active');
            updateIncrementalChart(region);
        });
    }
}

function updateIncrementalChart(region) {
    if (!incrementalMixChart || !DATA) return;
    currentIncrementalRegion = region;
    const data = getIncrementalData(region);

    const newDatasets = buildIncrementalDatasets(data);
    incrementalMixChart.data.labels = data.labels;
    newDatasets.forEach((ds, i) => {
        incrementalMixChart.data.datasets[i].data = ds.data;
    });

    // Update existing boundary
    incrementalMixChart._existingBoundary = data.labels.map((_, i) => {
        let total = 0;
        MIX_RESOURCES.forEach(r => { total += data.existingData[r][i]; });
        return total;
    });
    incrementalMixChart._incrNewData = data.newData;

    // Update existing clean line annotation
    const ann = incrementalMixChart.options.plugins.annotation.annotations;
    ann.existingLine.yMin = data.existingCleanTotal;
    ann.existingLine.yMax = data.existingCleanTotal;
    ann.existingLine.label.content = 'Current grid clean: ' + Math.round(data.existingCleanTotal) + '%';

    // Update y-axis max
    const maxTotal = data.labels.map((_, i) => {
        let sum = 0;
        MIX_RESOURCES.forEach(r => { sum += data.existingData[r][i] + data.newData[r][i]; });
        return sum;
    });
    incrementalMixChart.options.scales.y.max = Math.ceil(Math.max(...maxTotal) / 10) * 10 + 10;

    incrementalMixChart.update();

    const insightEl = document.getElementById('incrementalInsight');
    if (insightEl && INCREMENTAL_INSIGHTS[region]) {
        insightEl.innerHTML = INCREMENTAL_INSIGHTS[region];
    }
}

// ---- Narrative Cost Chart (Scrollytelling) ----
let narrativeCostChart = null;

function initNarrativeCostChart() {
    const canvas = document.getElementById('narrativeCostChart');
    if (!canvas || !DATA) return;

    // Gather cost per threshold for each ISO + average
    // Use NUMERIC x-values so the axis is proportional (99â†’100 = 1% gap vs 5% gaps)
    const thresholdKeys = ['75', '80', '85', '90', '95', '99', '100'];
    const thresholdNums = [75, 80, 85, 90, 95, 99, 100];
    const isos = Object.keys(DATA.results);
    const xValues = [];     // numeric x positions
    const avgCosts = [];
    const isoData = {};

    // ISO line colors (thin, translucent)
    const isoLineColors = {
        'CAISO': 'rgba(245,158,11,0.4)',
        'ERCOT': 'rgba(34,197,94,0.4)',
        'PJM':   'rgba(14,165,233,0.4)',
        'NYISO': 'rgba(239,68,68,0.4)',
        'NEISO': 'rgba(138,129,120,0.4)',
    };

    for (const iso of isos) isoData[iso] = [];

    for (let ti = 0; ti < thresholdKeys.length; ti++) {
        const tk = thresholdKeys[ti];
        let costSum = 0, count = 0;
        let hasData = false;
        for (const iso of isos) {
            const reg = DATA.results[iso];
            const t = reg ? resolveEntry(reg, tk) : null;
            if (t && t.costs?.effective_cost_per_useful_mwh) {
                const cost = t.costs.effective_cost_per_useful_mwh;
                isoData[iso].push({ x: thresholdNums[ti], y: Math.round(cost) });
                costSum += cost;
                count++;
                hasData = true;
            } else {
                isoData[iso].push({ x: thresholdNums[ti], y: null });
            }
        }
        if (hasData) {
            xValues.push(thresholdNums[ti]);
            avgCosts.push({ x: thresholdNums[ti], y: Math.round(costSum / count) });
        }
    }

    if (xValues.length === 0) return;

    const ctx = canvas.getContext('2d');

    // Create gradient fill for the average line
    const gradient = ctx.createLinearGradient(0, 0, 0, 340);
    gradient.addColorStop(0, 'rgba(26,39,68,0.12)');
    gradient.addColorStop(1, 'rgba(26,39,68,0.01)');

    // Point colors â€” all start muted, will be highlighted by scroll
    const pointColors = avgCosts.map(() => 'rgba(26,39,68,0.3)');
    const pointRadii = avgCosts.map(() => 5);

    // Build datasets: individual ISO lines (thin, behind) + bold average line (front)
    const datasets = [];

    // Individual ISO lines
    for (const iso of isos) {
        const isoLabel = DATA.results[iso]?.label || iso;
        datasets.push({
            label: isoLabel,
            data: isoData[iso].filter(d => d.y !== null),
            borderColor: isoLineColors[iso] || 'rgba(150,150,150,0.3)',
            backgroundColor: 'transparent',
            borderWidth: 1.5,
            borderDash: [4, 3],
            pointRadius: 0,
            pointHoverRadius: 4,
            pointBackgroundColor: isoLineColors[iso] || 'rgba(150,150,150,0.3)',
            fill: false,
            tension: 0.35,
            order: 2,
        });
    }

    // Average line (bold, on top)
    datasets.push({
        label: 'Avg Cost ($/MWh)',
        data: avgCosts,
        borderColor: '#1A2744',
        backgroundColor: gradient,
        borderWidth: 3,
        pointBackgroundColor: pointColors,
        pointBorderColor: pointColors,
        pointRadius: pointRadii,
        pointHoverRadius: 8,
        fill: true,
        tension: 0.35,
        order: 1,
    });

    narrativeCostChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: datasets,
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 600, easing: 'easeOutCubic' },
            layout: { padding: { top: 44, right: 16, bottom: 4, left: 4 } },
            interaction: {
                mode: 'nearest',
                intersect: false,
                axis: 'x',
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'bottom',
                    labels: {
                        usePointStyle: true,
                        pointStyle: 'line',
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11 },
                        color: '#1A1A1A',
                        padding: 14,
                        boxWidth: 20,
                        boxHeight: 1,
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(26,39,68,0.92)',
                    titleFont: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 13, weight: 600 },
                    bodyFont: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12 },
                    padding: 12,
                    cornerRadius: 8,
                    callbacks: {
                        title: function(items) {
                            if (items.length > 0) return items[0].parsed.x + '% Target';
                            return '';
                        },
                        label: function(context) {
                            if (context.parsed.y == null) return null;
                            return ` ${context.dataset.label}: $${context.parsed.y}/MWh`;
                        }
                    }
                },
                annotation: {
                    annotations: {}
                }
            },
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: 'Hourly Matching Target',
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12, weight: 600 },
                        color: '#4A4540',
                    },
                    grid: { display: false }, border: { display: true, color: '#D4D8E0' },
                    ticks: {
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11 },
                        color: '#6B6356',
                        callback: (v) => v + '%',
                        stepSize: 5,
                    },
                    min: 73,
                    max: 102,
                },
                y: {
                    title: {
                        display: true,
                        text: 'Blended Cost ($/MWh)',
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12, weight: 600 },
                        color: '#4A4540',
                    },
                    grid: { display: false }, border: { display: true, color: '#D4D8E0' },
                    ticks: {
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11 },
                        color: '#6B6356',
                        callback: (v) => '$' + v,
                    },
                    beginAtZero: true,
                    grace: '15%',
                }
            }
        }
    });
}

function refreshNarrativeCostChart() {
    if (!narrativeCostChart || !DATA) return;
    const thresholdKeys = ['75', '80', '85', '90', '95', '99', '100'];
    const thresholdNums = [75, 80, 85, 90, 95, 99, 100];
    const isos = Object.keys(DATA.results);
    const dsCount = narrativeCostChart.data.datasets.length;

    // Update individual ISO line datasets
    for (let di = 0; di < isos.length; di++) {
        const iso = isos[di];
        const newData = [];
        for (let ti = 0; ti < thresholdKeys.length; ti++) {
            const cost = getAdjustedEffectiveCost(iso, thresholdKeys[ti]);
            if (cost != null) {
                newData.push({ x: thresholdNums[ti], y: Math.round(cost) });
            }
        }
        if (di < dsCount - 1) {
            narrativeCostChart.data.datasets[di].data = newData;
        }
    }

    // Update average line (last dataset)
    const avgDs = narrativeCostChart.data.datasets[dsCount - 1];
    const newAvg = [];
    for (let ti = 0; ti < thresholdKeys.length; ti++) {
        let sum = 0, count = 0;
        for (const iso of isos) {
            const cost = getAdjustedEffectiveCost(iso, thresholdKeys[ti]);
            if (cost != null) { sum += cost; count++; }
        }
        if (count > 0) newAvg.push({ x: thresholdNums[ti], y: Math.round(sum / count) });
    }
    avgDs.data = newAvg;

    narrativeCostChart.update();
}

function highlightCostStep(stepName) {
    if (!narrativeCostChart) return;

    // Average line is the LAST dataset (individual ISOs are before it)
    const dsCount = narrativeCostChart.data.datasets.length;
    const ds = narrativeCostChart.data.datasets[dsCount - 1]; // avg line
    const n = ds.data.length;

    // Helper: find data index by x value (threshold number)
    const findIdx = (xVal) => ds.data.findIndex(d => d.x === xVal);
    const getY = (idx) => idx >= 0 ? ds.data[idx].y : null;
    const getX = (idx) => idx >= 0 ? ds.data[idx].x : null;

    // Reset all points to muted
    const colors = new Array(n).fill('rgba(26,39,68,0.25)');
    const radii = new Array(n).fill(5);
    const annotations = {};

    if (stepName === 'cost-intro') {
        // Highlight all â€” full curve glow
        for (let i = 0; i < n; i++) {
            colors[i] = '#1A2744';
            radii[i] = 6;
        }
    } else if (stepName === 'cost-75') {
        // Highlight 75%
        const idx = findIdx(75);
        if (idx >= 0) {
            colors[idx] = '#22C55E';
            radii[idx] = 10;
            annotations['highlight'] = {
                type: 'point',
                xValue: 75,
                yValue: getY(idx),
                backgroundColor: 'rgba(34,197,94,0.15)',
                borderColor: '#22C55E',
                borderWidth: 2,
                radius: 18,
            };
            annotations['label75'] = {
                type: 'label',
                xValue: 75,
                yValue: getY(idx),
                content: '$' + getY(idx) + '/MWh',
                font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 13, weight: 700 },
                color: '#22C55E',
                backgroundColor: 'rgba(255,255,255,0.88)',
                borderRadius: 4,
                padding: { top: 4, bottom: 4, left: 6, right: 6 },
                position: 'start',
                yAdjust: -48,
            };
        }
    } else if (stepName === 'cost-90') {
        // Highlight 75% through 90% range
        const idx75 = findIdx(75);
        const idx90 = findIdx(90);
        if (idx75 >= 0 && idx90 >= 0) {
            for (let i = idx75; i <= idx90; i++) {
                colors[i] = '#EF4444';
                radii[i] = 7;
            }
            radii[idx90] = 10;
            annotations['highlight90'] = {
                type: 'point',
                xValue: 90,
                yValue: getY(idx90),
                backgroundColor: 'rgba(239,68,68,0.15)',
                borderColor: '#EF4444',
                borderWidth: 2,
                radius: 18,
            };
            annotations['label90'] = {
                type: 'label',
                xValue: 90,
                yValue: getY(idx90),
                content: '$' + getY(idx90) + '/MWh',
                font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 13, weight: 700 },
                color: '#EF4444',
                backgroundColor: 'rgba(255,255,255,0.88)',
                borderRadius: 4,
                padding: { top: 4, bottom: 4, left: 6, right: 6 },
                position: 'start',
                yAdjust: -48,
            };
            // Shade the region
            annotations['zone'] = {
                type: 'box',
                xMin: 74,
                xMax: 91,
                backgroundColor: 'rgba(239,68,68,0.04)',
                borderColor: 'transparent',
            };
        }
    } else if (stepName === 'cost-99') {
        // Highlight 99-100% zone â€” the steep climb
        const idx99 = findIdx(99);
        const idx100 = findIdx(100);
        const topIdx = idx100 >= 0 ? idx100 : idx99;
        if (idx99 >= 0) {
            colors[idx99] = '#EF4444';
            radii[idx99] = 10;
            if (idx100 >= 0) {
                colors[idx100] = '#EF4444';
                radii[idx100] = 10;
            }
            annotations['highlight99'] = {
                type: 'point',
                xValue: getX(topIdx),
                yValue: getY(topIdx),
                backgroundColor: 'rgba(239,68,68,0.15)',
                borderColor: '#EF4444',
                borderWidth: 2,
                radius: 18,
            };
            annotations['label99'] = {
                type: 'label',
                xValue: getX(topIdx),
                yValue: getY(topIdx),
                content: '$' + getY(topIdx) + '/MWh',
                font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 13, weight: 700 },
                color: '#EF4444',
                backgroundColor: 'rgba(255,255,255,0.92)',
                borderRadius: 4,
                padding: { top: 4, bottom: 4, left: 6, right: 6 },
                position: 'start',
                xAdjust: -50,
                yAdjust: -48,
            };
            annotations['premiumLabel'] = {
                type: 'label',
                xValue: getX(topIdx),
                yValue: getY(topIdx),
                content: 'PREMIUM',
                font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 9, weight: 600 },
                color: 'rgba(239,68,68,0.55)',
                backgroundColor: 'transparent',
                position: 'end',
                xAdjust: -90,
                yAdjust: 8,
            };
            // Danger zone shading â€” 99 to 100 is proportionally narrow
            annotations['dangerZone'] = {
                type: 'box',
                xMin: 98.5,
                xMax: 100.5,
                backgroundColor: 'rgba(239,68,68,0.06)',
                borderColor: 'rgba(239,68,68,0.2)',
                borderWidth: 1.5,
            };
        }
    }

    // Apply
    ds.pointBackgroundColor = colors;
    ds.pointBorderColor = colors;
    ds.pointRadius = radii;
    narrativeCostChart.options.plugins.annotation.annotations = annotations;
    narrativeCostChart.update('none');
}

// ---- Mobile inline step charts ----
let stepChartInstances = {};

function isMobileScrolly() {
    return window.matchMedia('(max-width: 1024px)').matches;
}

function buildStepChartData() {
    if (!DATA) return null;
    const thresholdKeys = ['75', '80', '85', '90', '95', '99', '100'];
    const thresholdNums = [75, 80, 85, 90, 95, 99, 100];
    const isos = Object.keys(DATA.results);
    const avgCosts = [];
    const isoData = {};
    const isoLineColors = {
        'CAISO': 'rgba(245,158,11,0.4)',
        'ERCOT': 'rgba(34,197,94,0.4)',
        'PJM':   'rgba(14,165,233,0.4)',
        'NYISO': 'rgba(239,68,68,0.4)',
        'NEISO': 'rgba(138,129,120,0.4)',
    };
    for (const iso of isos) isoData[iso] = [];
    for (let ti = 0; ti < thresholdKeys.length; ti++) {
        const tk = thresholdKeys[ti];
        let costSum = 0, count = 0;
        for (const iso of isos) {
            const reg = DATA.results[iso];
            const t = reg ? resolveEntry(reg, tk) : null;
            if (t && t.costs?.effective_cost_per_useful_mwh) {
                const cost = t.costs.effective_cost_per_useful_mwh;
                isoData[iso].push({ x: thresholdNums[ti], y: Math.round(cost) });
                costSum += cost; count++;
            } else {
                isoData[iso].push({ x: thresholdNums[ti], y: null });
            }
        }
        if (count > 0) {
            avgCosts.push({ x: thresholdNums[ti], y: Math.round(costSum / count) });
        }
    }
    return { avgCosts, isoData, isos, isoLineColors };
}

function getStepAnnotations(stepName, avgCosts) {
    const findIdx = (xVal) => avgCosts.findIndex(d => d.x === xVal);
    const getY = (idx) => idx >= 0 ? avgCosts[idx].y : null;
    const getX = (idx) => idx >= 0 ? avgCosts[idx].x : null;
    const n = avgCosts.length;
    const colors = new Array(n).fill('rgba(26,39,68,0.25)');
    const radii = new Array(n).fill(4);
    const annotations = {};

    if (stepName === 'cost-intro') {
        for (let i = 0; i < n; i++) { colors[i] = '#1A2744'; radii[i] = 5; }
    } else if (stepName === 'cost-75') {
        const idx = findIdx(75);
        if (idx >= 0) {
            colors[idx] = '#22C55E'; radii[idx] = 8;
            annotations['highlight'] = { type: 'point', xValue: 75, yValue: getY(idx), backgroundColor: 'rgba(34,197,94,0.15)', borderColor: '#22C55E', borderWidth: 2, radius: 14 };
            annotations['label75'] = { type: 'label', xValue: 75, yValue: getY(idx), content: '$' + getY(idx) + '/MWh', font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11, weight: 700 }, color: '#22C55E', backgroundColor: 'rgba(255,255,255,0.88)', borderRadius: 4, padding: { top: 3, bottom: 3, left: 5, right: 5 }, position: 'start', yAdjust: -42 };
        }
    } else if (stepName === 'cost-90') {
        const idx75 = findIdx(75), idx90 = findIdx(90);
        if (idx75 >= 0 && idx90 >= 0) {
            for (let i = idx75; i <= idx90; i++) { colors[i] = '#EF4444'; radii[i] = 5; }
            radii[idx90] = 8;
            annotations['highlight90'] = { type: 'point', xValue: 90, yValue: getY(idx90), backgroundColor: 'rgba(239,68,68,0.15)', borderColor: '#EF4444', borderWidth: 2, radius: 14 };
            annotations['label90'] = { type: 'label', xValue: 90, yValue: getY(idx90), content: '$' + getY(idx90) + '/MWh', font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11, weight: 700 }, color: '#EF4444', backgroundColor: 'rgba(255,255,255,0.88)', borderRadius: 4, padding: { top: 3, bottom: 3, left: 5, right: 5 }, position: 'start', yAdjust: -42 };
            annotations['zone'] = { type: 'box', xMin: 74, xMax: 91, backgroundColor: 'rgba(239,68,68,0.04)', borderColor: 'transparent' };
        }
    } else if (stepName === 'cost-99') {
        const idx99 = findIdx(99), idx100 = findIdx(100);
        const topIdx = idx100 >= 0 ? idx100 : idx99;
        if (idx99 >= 0) {
            colors[idx99] = '#EF4444'; radii[idx99] = 8;
            if (idx100 >= 0) { colors[idx100] = '#EF4444'; radii[idx100] = 8; }
            annotations['highlight99'] = { type: 'point', xValue: getX(topIdx), yValue: getY(topIdx), backgroundColor: 'rgba(239,68,68,0.15)', borderColor: '#EF4444', borderWidth: 2, radius: 14 };
            annotations['label99'] = { type: 'label', xValue: getX(topIdx), yValue: getY(topIdx), content: '$' + getY(topIdx) + '/MWh', font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11, weight: 700 }, color: '#EF4444', backgroundColor: 'rgba(255,255,255,0.92)', borderRadius: 4, padding: { top: 3, bottom: 3, left: 5, right: 5 }, position: 'start', xAdjust: -40, yAdjust: -42 };
            annotations['dangerZone'] = { type: 'box', xMin: 98.5, xMax: 100.5, backgroundColor: 'rgba(239,68,68,0.06)', borderColor: 'rgba(239,68,68,0.2)', borderWidth: 1.5 };
        }
    }
    return { colors, radii, annotations };
}

function initMobileStepCharts() {
    if (!isMobileScrolly() || !DATA) return;
    const chartData = buildStepChartData();
    if (!chartData || chartData.avgCosts.length === 0) return;

    document.querySelectorAll('.step-chart-canvas').forEach(canvas => {
        const stepName = canvas.getAttribute('data-step-chart');
        if (stepChartInstances[stepName]) { stepChartInstances[stepName].destroy(); }

        const ctx = canvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 0, 200);
        gradient.addColorStop(0, 'rgba(26,39,68,0.12)');
        gradient.addColorStop(1, 'rgba(26,39,68,0.01)');

        const { colors, radii, annotations } = getStepAnnotations(stepName, chartData.avgCosts);

        const datasets = [];
        // ISO lines
        for (const iso of chartData.isos) {
            datasets.push({
                label: DATA.results[iso]?.label || iso,
                data: chartData.isoData[iso].filter(d => d.y !== null),
                borderColor: chartData.isoLineColors[iso] || 'rgba(150,150,150,0.3)',
                backgroundColor: 'transparent',
                borderWidth: 1, borderDash: [4, 3], pointRadius: 0, fill: false, tension: 0.35, order: 2,
            });
        }
        // Average line
        datasets.push({
            label: 'Avg Cost ($/MWh)',
            data: [...chartData.avgCosts],
            borderColor: '#1A2744', backgroundColor: gradient, borderWidth: 2.5,
            pointBackgroundColor: colors, pointBorderColor: colors, pointRadius: radii,
            fill: true, tension: 0.35, order: 1,
        });

        stepChartInstances[stepName] = new Chart(ctx, {
            type: 'line',
            data: { datasets },
            options: {
                responsive: true, maintainAspectRatio: false,
                animation: { duration: 0 },
                layout: { padding: { top: 30, right: 10, bottom: 2, left: 2 } },
                interaction: { mode: 'nearest', intersect: false, axis: 'x' },
                plugins: {
                    legend: { display: false },
                    tooltip: { enabled: false },
                    annotation: { annotations }
                },
                scales: {
                    x: {
                        type: 'linear', min: 73, max: 102,
                        title: { display: false },
                        grid: { display: false }, border: { display: true, color: '#D4D8E0' },
                        ticks: {
                            font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 10 },
                            color: '#6B6356', callback: (v) => v + '%', stepSize: 5,
                        },
                    },
                    y: {
                        title: { display: false },
                        grid: { display: false }, border: { display: true, color: '#D4D8E0' },
                        ticks: {
                            font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 10 },
                            color: '#6B6356', callback: (v) => '$' + v,
                        },
                    }
                }
            }
        });
    });
}

// ---- Scroll-triggered fade-in + scrollytelling step observer ----
function initScrollAnimations() {
    // 1. Fade-in observer for story sections and scrolly steps
    const fadeObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('visible');
            }
        });
    }, { threshold: 0.15, rootMargin: '0px 0px -50px 0px' });

    document.querySelectorAll('.story-fade-in').forEach(el => {
        fadeObserver.observe(el);
    });

    // 2. Scrollytelling step observer â€” highlight cost chart based on active step
    const steps = document.querySelectorAll('.scrolly-step');
    if (steps.length === 0) return;

    let activeStep = null;
    const stepObserver = new IntersectionObserver((entries) => {
        // Find the most-visible step
        let best = null;
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                if (!best || entry.intersectionRatio > best.intersectionRatio) {
                    best = entry;
                }
            }
        });

        if (best) {
            const stepEl = best.target;
            const stepName = stepEl.getAttribute('data-step');

            if (stepName !== activeStep) {
                activeStep = stepName;
                // Remove active from all
                steps.forEach(s => s.classList.remove('active'));
                stepEl.classList.add('active');
                highlightCostStep(stepName);
            }
        }
    }, {
        threshold: [0.1, 0.3, 0.5, 0.7, 0.9],
        rootMargin: '-20% 0px -30% 0px'
    });

    steps.forEach(step => stepObserver.observe(step));

    // 3. Initialize the narrative cost chart when it scrolls into view
    const chartContainer = document.querySelector('.scrolly-container');
    if (chartContainer) {
        const chartInitObserver = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && !narrativeCostChart) {
                initNarrativeCostChart();
                // Start with the intro highlight
                setTimeout(() => highlightCostStep('cost-intro'), 300);
            }
        }, { threshold: 0.05 });
        chartInitObserver.observe(chartContainer);
    }

    // 4. Initialize the narrative mix chart when it scrolls into view
    const mixCanvas = document.getElementById('narrativeMixChart');
    if (mixCanvas) {
        const mixInitObserver = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && !narrativeMixChart) {
                initNarrativeMixChart();
            }
        }, { threshold: 0.05 });
        mixInitObserver.observe(mixCanvas.closest('.story-section') || mixCanvas);
    }

    // 5. Initialize the incremental mix chart when it scrolls into view
    const incrCanvas = document.getElementById('incrementalMixChart');
    if (incrCanvas) {
        const incrInitObserver = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && !incrementalMixChart) {
                initIncrementalMixChart();
            }
        }, { threshold: 0.05 });
        incrInitObserver.observe(incrCanvas.closest('.story-section') || incrCanvas);
    }
}

// ---- Target Mode Toggle (Interim / Long-term) ----
function initTargetModeToggle() {
    const togglePanel = document.getElementById('targetModeToggle');
    if (!togglePanel) return;
    togglePanel.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', function() {
            togglePanel.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            currentTargetMode = this.getAttribute('data-mode');
            if (DATA) updateAll();
        });
    });
}

function updateTargetModeInfo() {
    const infoEl = document.getElementById('targetModeInfo');
    if (!infoEl) return;
    const interimThresh = document.getElementById('thresholdSelect').value;
    const longtermVal = document.getElementById('longtermTarget').value;
    if (currentTargetMode === 'longterm' && longtermVal) {
        infoEl.innerHTML = `Showing <strong>long-term ${longtermVal}%</strong> target results. All charts below reflect the long-term matching goal.`;
    } else if (currentTargetMode === 'longterm' && !longtermVal) {
        infoEl.innerHTML = `Long-term target not set â€” showing <strong>interim ${interimThresh}%</strong> results. Select a long-term target above.`;
    } else {
        infoEl.innerHTML = `Showing <strong>interim ${interimThresh}%</strong> target results. All charts below reflect the interim matching goal.`;
    }
}

// ---- Heatmap Tile Coloring (5 groups: green â†’ red) ----
function getHeatmapClass(value, min, max, invertDirection) {
    // invertDirection=true means higher is worse (red), false means higher is better (green)
    if (value == null || isNaN(value) || min === max) return 'heatmap-3';
    const pct = (value - min) / (max - min); // 0 = min, 1 = max
    // For inverted (higher = worse): pct 0â†’green, pct 1â†’red
    // For normal (higher = better): pct 0â†’red, pct 1â†’green
    const normalizedPct = invertDirection ? pct : (1 - pct);
    if (normalizedPct <= 0.2) return 'heatmap-1';      // green (best)
    if (normalizedPct <= 0.4) return 'heatmap-2';      // yellow-green
    if (normalizedPct <= 0.6) return 'heatmap-3';      // yellow
    if (normalizedPct <= 0.8) return 'heatmap-4';      // orange
    return 'heatmap-5';                                  // red (worst)
}

function updateHeatmapTiles(region, entry, iso) {
    // Collect ranges across all thresholds for this ISO
    const thresholds = Object.keys(region.thresholds);
    let minIncr = Infinity, maxIncr = -Infinity;
    let minMatch = Infinity, maxMatch = -Infinity;
    let minProc = Infinity, maxProc = -Infinity;
    let minCurt = Infinity, maxCurt = -Infinity;
    let minCO2 = Infinity, maxCO2 = -Infinity;
    let minAbateCost = Infinity, maxAbateCost = -Infinity;

    thresholds.forEach(tk => {
        const e = resolveEntry(region, tk);
        if (!e) return;
        const c = e.costs || {};
        const adj = cfAdjust(e, iso);
        const incr = adj.newIncremental;
        const match = e.hourly_match_score || 0;
        const proc = e.procurement_pct || 0;
        const curt = c.curtailment_pct || 0;
        const co2 = e.co2_abated_tons || 0;

        if (incr != null) { minIncr = Math.min(minIncr, incr); maxIncr = Math.max(maxIncr, incr); }
        minMatch = Math.min(minMatch, match); maxMatch = Math.max(maxMatch, match);
        minProc = Math.min(minProc, proc); maxProc = Math.max(maxProc, proc);
        minCurt = Math.min(minCurt, curt); maxCurt = Math.max(maxCurt, curt);
        minCO2 = Math.min(minCO2, co2); maxCO2 = Math.max(maxCO2, co2);

        // Abatement cost estimate
        if (co2 > 0 && incr != null) {
            const annDemandMWh = region.annual_demand_mwh || 1;
            const abateCost = (incr * annDemandMWh) / co2;
            minAbateCost = Math.min(minAbateCost, abateCost);
            maxAbateCost = Math.max(maxAbateCost, abateCost);
        }
    });

    const adj = cfAdjust(entry, iso);
    const c = entry.costs || {};

    // Apply heatmap classes
    const heatmapClasses = ['heatmap-1', 'heatmap-2', 'heatmap-3', 'heatmap-4', 'heatmap-5'];
    function applyHeatmap(tileId, value, min, max, invertDirection) {
        const tile = document.getElementById(tileId);
        if (!tile) return;
        tile.classList.remove(...heatmapClasses, 'tile-negative');
        tile.classList.add(getHeatmapClass(value, min, max, invertDirection));
    }

    // Match score: higher = green
    applyHeatmap('tileMatch', entry.hourly_match_score, minMatch, maxMatch, false);
    // Procurement: higher = red (more costly)
    applyHeatmap('tileProcure', entry.procurement_pct, minProc, maxProc, true);
    // Incremental cost: higher = red
    applyHeatmap('tileCost', adj.newIncremental, minIncr, maxIncr, true);
    // Curtailment: higher = red
    applyHeatmap('tileCurtail', c.curtailment_pct || 0, minCurt, maxCurt, true);
    // CO2 abated: higher = green
    applyHeatmap('tileCO2', entry.co2_abated_tons || 0, minCO2, maxCO2, false);

    // Abatement cost tile
    const co2Tons = entry.co2_abated_tons || 0;
    const abateCostEl = document.getElementById('metricAbateCost');
    const abateCostSub = document.getElementById('metricAbateCostSub');
    if (abateCostEl && co2Tons > 0 && adj.newIncremental != null) {
        const annDemandMWh = region.annual_demand_mwh || 1;
        const avgAbateCost = (adj.newIncremental * annDemandMWh) / co2Tons;
        abateCostEl.textContent = '$' + formatNum(avgAbateCost) + '/ton';

        // Marginal abatement cost: approximate from neighboring threshold
        const currentThresh = parseFloat(findClosestThreshold(region, document.getElementById('thresholdSelect').value));
        const sortedThresholds = Object.keys(region.thresholds).map(Number).sort((a, b) => a - b);
        const idx = sortedThresholds.indexOf(currentThresh);
        let marginalCost = null;
        if (idx > 0) {
            const prevThresh = sortedThresholds[idx - 1];
            const prevEntry = resolveEntry(region, String(prevThresh));
            if (prevEntry) {
                const prevAdj = cfAdjust(prevEntry, iso);
                const prevCO2 = prevEntry.co2_abated_tons || 0;
                const deltaCost = (adj.newIncremental - prevAdj.newIncremental) * annDemandMWh;
                const deltaCO2 = co2Tons - prevCO2;
                if (deltaCO2 > 0) {
                    marginalCost = deltaCost / deltaCO2;
                }
            }
        }
        if (marginalCost != null) {
            abateCostSub.textContent = `$${formatNum(marginalCost)}/ton marginal`;
        } else {
            abateCostSub.textContent = '$/ton CO\u2082 avg';
        }

        applyHeatmap('tileAbateCost', avgAbateCost, minAbateCost, maxAbateCost, true);
    } else {
        if (abateCostEl) abateCostEl.textContent = '--';
        if (abateCostSub) abateCostSub.textContent = '$/ton CO\u2082';
        const tile = document.getElementById('tileAbateCost');
        if (tile) { tile.classList.remove(...heatmapClasses, 'tile-negative'); }
    }
}

// ---- Sensitivity Toggle State (5 Paired Groups) ----
const sensitivityState = {
    renewable_gen: 'Medium',   // Solar + Wind LCOE
    firm_gen: 'Medium',        // Clean Firm + CCS-CCGT LCOE
    storage: 'Medium',         // Battery (4hr) + LDES (100hr) LCOS
    fossil_fuel: 'Medium',     // Wholesale electricity price driver
    transmission: 'Medium'     // All resource transmission adders
};

function initSensitivityToggles() {
    document.querySelectorAll('.toggle-btn-group').forEach(group => {
        const toggleKey = group.getAttribute('data-toggle');
        if (!toggleKey) return;
        group.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('click', function() {
                // Update active state
                group.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                // Update state
                sensitivityState[toggleKey] = this.getAttribute('data-value');
                // Trigger recalculation if data is available
                if (DATA) {
                    updateAll();
                    // Re-render narrative if initialized
                    if (typeof narrativeCostChart !== 'undefined' && narrativeCostChart) {
                        refreshNarrativeCostChart();
                    }
                    if (typeof refreshNarrativeStats === 'function') {
                        refreshNarrativeStats();
                    }
                }
            });
        });
    });
}

// ---- CO2 Metric Tile Update ----
function updateCO2Tile(entry) {
    const el = document.getElementById('metricCO2Abated');
    const sub = document.getElementById('metricCO2AbatedSub');
    if (!el) return;
    // Check if CO2 data exists in the entry
    if (entry && entry.co2_abated_tons != null) {
        el.textContent = formatCommas(Math.round(entry.co2_abated_tons));
        sub.textContent = 'tons';
    } else {
        el.textContent = '--';
        sub.textContent = 'tons';
    }
}

// ---- What You Need: Existing â†’ Interim â†’ Long-term in TWh ----
let wynCompareChartInstance = null;

function updateWhatYouNeedPanel(region, entry, threshold) {
    // This is called on every dashboard update; it renders the 3-bar TWh chart
    // and computes stranded investment metrics.
    const canvas = document.getElementById('wynCompareChart');
    const insightBox = document.getElementById('wynInsightBox');
    const metricsEl = document.getElementById('wynMetrics');
    if (!canvas || !DATA) return;

    const iso = document.getElementById('regionSelect').value;
    const regionData = DATA.results?.[iso];
    if (!regionData || !entry) return;

    const annualDemandMWh = regionData.annual_demand_mwh || 1;
    const annualDemandTWh = annualDemandMWh / 1e6;

    // Get interim entry resource costs
    const interimRC = entry.costs?.resource_costs;
    if (!interimRC) {
        if (insightBox) insightBox.innerHTML = 'Resource cost data not available for this threshold.';
        return;
    }

    // Long-term target
    const longtermVal = document.getElementById('longtermTarget').value;
    const longtermThreshold = longtermVal ? findClosestThreshold(regionData, longtermVal) : null;
    const longtermEntry = longtermThreshold ? resolveEntry(regionData, longtermThreshold) : null;
    const longtermRC = longtermEntry?.costs?.resource_costs;

    // Time horizons and demand growth
    const interimYear = parseInt(document.getElementById('interimYear')?.value || '2029', 10);
    const longtermYear = parseInt(document.getElementById('longtermYear')?.value || '2042', 10);
    const yearsToInterim = Math.max(1, interimYear - 2025);
    const yearsToLongterm = Math.max(1, longtermYear - 2025);

    const growthLevel = getDemandGrowthLevel();
    const rates = DEMAND_GROWTH_RATES[iso] || DEMAND_GROWTH_RATES.CAISO;
    const annualRate = rates[growthLevel] || rates.Medium;
    const interimGrowthFactor = Math.pow(1 + annualRate, yearsToInterim);
    const longtermGrowthFactor = Math.pow(1 + annualRate, yearsToLongterm);

    // TWh at each stage
    const todayTWh = annualDemandTWh;
    const interimTWh = annualDemandTWh * interimGrowthFactor;
    const longtermTWh = longtermRC ? annualDemandTWh * longtermGrowthFactor : null;

    // Helper: extract resource data for a resource_costs object
    // Existing resources are FIXED at today's absolute TWh (2025 actuals).
    // New build scales with demand growth at the target time horizon.
    function getResourceTWh(rc, targetDemandTWh) {
        const existing = {};
        const newBuild = {};
        MIX_RESOURCES.forEach(r => {
            if (r === 'storage') {
                existing[r] = 0;
                newBuild[r] = (rc.storage?.dispatch_pct || 0) / 100 * targetDemandTWh;
            } else {
                // Existing is always today's absolute TWh â€” does not grow
                existing[r] = (rc[r]?.existing_pct || 0) / 100 * todayTWh;
                // New build scales with demand at the target year
                newBuild[r] = (rc[r]?.new_pct || 0) / 100 * targetDemandTWh;
            }
        });
        return { existing, newBuild };
    }

    // Today: existing clean only (no target, no new build)
    const todayData = getResourceTWh(interimRC, todayTWh);
    // Interim target (new build scaled to interim demand)
    const interimData = getResourceTWh(interimRC, interimTWh);
    // Long-term target (new build scaled to longterm demand)
    const longtermData = longtermRC ? getResourceTWh(longtermRC, longtermTWh) : null;

    // Build chart labels â€” simple: Existing / Interim / Long-term
    const hasLongterm = longtermData !== null;
    const labels = hasLongterm
        ? ['Existing', 'Interim', 'Long-term']
        : ['Existing', 'Interim'];

    // Stack order: existing bottom-up (clean_firm, hydro, wind, solar), then
    // new build inverted so solar is on top (clean_firm, storage, hydro, wind, solar)
    const EXISTING_ORDER = ['clean_firm', 'hydro', 'wind', 'solar'];
    const NEW_ORDER = ['clean_firm', 'storage', 'hydro', 'wind', 'solar'];
    const existingAlpha = 0.75;
    const newAlpha = 0.40;
    const datasets = [];

    // Existing portion datasets (full saturation)
    for (const r of EXISTING_ORDER) {
        const c = MIX_COLORS[r];
        const data = hasLongterm
            ? [todayData.existing[r], interimData.existing[r], longtermData.existing[r]]
            : [todayData.existing[r], interimData.existing[r]];
        datasets.push({
            label: MIX_LABELS_MAP[r] + ' (existing)',
            data,
            backgroundColor: c.fill.replace(/[\d.]+\)$/, existingAlpha + ')'),
            borderColor: c.border,
            borderWidth: 1.5,
            borderRadius: 6,
            stack: 'compare',
            _resourceKey: r,
            _isExisting: true,
        });
    }
    // New build portion datasets (opaque, solar on top)
    for (const r of NEW_ORDER) {
        const c = MIX_COLORS[r];
        const data = hasLongterm
            ? [0, interimData.newBuild[r], longtermData.newBuild[r]]
            : [0, interimData.newBuild[r]];
        datasets.push({
            label: MIX_LABELS_MAP[r] + ' (new build)',
            data,
            backgroundColor: c.fill.replace(/[\d.]+\)$/, newAlpha + ')'),
            borderColor: c.border,
            borderWidth: 1,
            borderRadius: 6,
            borderSkipped: 'start',
            stack: 'compare',
            _resourceKey: r,
            _isExisting: false,
        });
    }

    // Compute bar totals, curtailment, and demand at each stage
    const barTotals = [];
    for (let i = 0; i < labels.length; i++) {
        let barTotal = 0;
        datasets.forEach(ds => { barTotal += ds.data[i] || 0; });
        barTotals.push(barTotal);
    }
    const demandAtStage = hasLongterm
        ? [todayTWh, interimTWh, longtermTWh]
        : [todayTWh, interimTWh];

    // Existing clean total for reference line
    let existingCleanTWh = 0;
    MIX_RESOURCES.forEach(r => { existingCleanTWh += todayData.existing[r]; });

    // Curtailment = procurement above demand (bar total - demand)
    const curtailmentTWh = barTotals.map((bt, i) => Math.max(0, bt - demandAtStage[i]));

    const maxTWh = Math.max(...barTotals, ...demandAtStage);
    const yMax = Math.ceil(maxTWh / 10) * 10 + 10; // extra room for labels

    // Custom plugin: bar-top labels only (clean TWh above each bar)
    const wynBarTopPlugin = {
        id: 'wynBarTopLabels',
        afterDraw(chart) {
            const { ctx: c, scales: { x, y } } = chart;
            c.save();
            for (let i = 0; i < barTotals.length; i++) {
                const xCenter = x.getPixelForValue(i);
                const yPos = y.getPixelForValue(barTotals[i]);
                c.font = "bold 12px 'Barlow Semi Condensed','Arial Narrow',sans-serif";
                c.textAlign = 'center';
                c.fillStyle = '#1A2744';
                c.fillText(Math.round(barTotals[i]) + ' TWh clean', xCenter, yPos - 8);
            }
            c.restore();
        }
    };

    if (wynCompareChartInstance) wynCompareChartInstance.destroy();
    const ctx = canvas.getContext('2d');
    wynCompareChartInstance = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets },
        plugins: [ChartDataLabels, wynBarTopPlugin],
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 600, easing: 'easeOutCubic' },
            layout: { padding: { top: 40, right: 8, bottom: 4, left: 4 } },
            plugins: {
                legend: {
                    display: true,
                    position: 'bottom',
                    labels: {
                        usePointStyle: true,
                        pointStyle: 'rectRounded',
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11 },
                        color: '#1A1A1A',
                        padding: 14,
                        generateLabels: function() {
                            const items = MIX_RESOURCES.map(r => ({
                                text: MIX_LABELS_MAP[r],
                                fillStyle: MIX_COLORS[r].fill,
                                strokeStyle: MIX_COLORS[r].border,
                                lineWidth: 2,
                                pointStyle: 'rectRounded',
                            }));
                            items.push({
                                text: 'Saturated = Existing',
                                fillStyle: 'rgba(100,100,100,0.75)',
                                strokeStyle: '#666',
                                lineWidth: 2,
                                pointStyle: 'rectRounded',
                            });
                            items.push({
                                text: 'Faded = New Build',
                                fillStyle: 'rgba(100,100,100,0.35)',
                                strokeStyle: '#999',
                                lineWidth: 2,
                                pointStyle: 'rectRounded',
                            });
                            return items;
                        }
                    },
                    onClick: () => {}
                },
                tooltip: {
                    backgroundColor: 'rgba(26,39,68,0.92)',
                    titleFont: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 13, weight: 600 },
                    bodyFont: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12 },
                    padding: 12,
                    cornerRadius: 8,
                    filter: function(tooltipItem) { return tooltipItem.parsed.y > 0.1; },
                    callbacks: {
                        label: function(context) {
                            return ` ${context.dataset.label}: ${context.parsed.y.toFixed(1)} TWh`;
                        }
                    }
                },
                datalabels: {
                    display: function(context) {
                        return context.dataset.data[context.dataIndex] >= (maxTWh * 0.03);
                    },
                    color: function(context) {
                        if (context.dataset._resourceKey === 'clean_firm') return '#FFFFFF';
                        return '#1A1A1A';
                    },
                    font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 10, weight: 700 },
                    formatter: function(value) {
                        if (value >= 10) return Math.round(value) + ' TWh';
                        return value.toFixed(1) + ' TWh';
                    },
                    anchor: 'center',
                    align: 'center',
                },
                annotation: { annotations: {} }
            },
            scales: {
                x: {
                    stacked: true,
                    grid: { display: false },
                    border: { display: true, color: '#D4D8E0' },
                    ticks: {
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 13, weight: 700 },
                        color: '#1A2744',
                        maxRotation: 0,
                        minRotation: 0,
                    }
                },
                y: {
                    stacked: true,
                    max: yMax,
                    title: {
                        display: true,
                        text: 'Clean Energy Procurement (TWh)',
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 12, weight: 600 },
                        color: '#4A4540',
                    },
                    grid: { display: false },
                    border: { display: true, color: '#D4D8E0' },
                    ticks: {
                        font: { family: "'Barlow Semi Condensed','Arial Narrow',sans-serif", size: 11 },
                        color: '#6B6356',
                        callback: (v) => v + ' TWh',
                    }
                }
            }
        }
    });

    // ---- Stranded Investment Calculation ----
    if (hasLongterm && metricsEl) {
        metricsEl.style.display = '';

        // Compare interim resource mix vs long-term resource mix
        // Resources built for interim that exceed long-term needs â†’ stranded
        let totalInterimProcTWh = 0;
        let totalCarriedTWh = 0;
        let totalStrandedCostM = 0; // in $M

        const strandedDetails = [];
        const allResources = new Set([...Object.keys(interimRC), ...Object.keys(longtermRC)]);

        allResources.forEach(r => {
            const intRes = interimRC[r] || {};
            const ltRes = longtermRC[r] || {};

            // Interim procurement at interim demand level, in TWh
            const interimTotalPct = intRes.total_pct_of_demand || 0;
            const interimCostPerDemandMWh = intRes.cost_per_demand_mwh || 0;
            const interimProcTWh = interimTotalPct / 100 * interimTWh;

            // Long-term needs at long-term demand level, in TWh
            const longtermTotalPct = ltRes.total_pct_of_demand || 0;
            const longtermNeedTWh = longtermTotalPct / 100 * longtermTWh;

            if (interimProcTWh <= 0) return;
            totalInterimProcTWh += interimProcTWh;

            // How much of interim procurement is absorbed by long-term?
            // Demand growth helps: interim capacity serves grown long-term demand
            const carriedTWh = Math.min(interimProcTWh, longtermNeedTWh);
            const strandedTWh = Math.max(0, interimProcTWh - longtermNeedTWh);
            totalCarriedTWh += carriedTWh;

            // Stranded cost = stranded TWh Ã— cost per MWh (proportional allocation)
            if (strandedTWh > 0) {
                const strandedCostM = strandedTWh * 1e6 * interimCostPerDemandMWh / 1e6; // $M
                totalStrandedCostM += strandedCostM;
                strandedDetails.push({
                    resource: RESOURCE_DISPLAY_NAMES[r] || r,
                    strandedTWh,
                    interimTWh: interimProcTWh,
                    longtermTWh: longtermNeedTWh,
                });
            }
        });

        const carriedPct = totalInterimProcTWh > 0
            ? (totalCarriedTWh / totalInterimProcTWh * 100) : 100;
        const strandedPct = 100 - carriedPct;

        // Also compute static (no growth) version for demand offset
        const staticInterimTWh_total = Object.keys(interimRC).reduce((s, r) => {
            return s + (interimRC[r]?.total_pct_of_demand || 0) / 100 * todayTWh;
        }, 0);
        const staticCarriedTWh = Object.keys(interimRC).reduce((s, r) => {
            const intPct = interimRC[r]?.total_pct_of_demand || 0;
            const ltPct = (longtermRC[r]?.total_pct_of_demand || 0);
            const intT = intPct / 100 * todayTWh;
            const ltT = ltPct / 100 * todayTWh; // no growth
            return s + Math.min(intT, ltT);
        }, 0);
        const staticCarriedPct = staticInterimTWh_total > 0
            ? (staticCarriedTWh / staticInterimTWh_total * 100) : 100;
        const demandOffset = carriedPct - staticCarriedPct;

        // Stranded cost as $/MWh of demand (more relatable)
        const strandedPerMWh = totalStrandedCostM * 1e6 / (interimTWh * 1e6);

        // Update metrics
        const pwCarried = document.getElementById('pwCarriedForward');
        const pwWasted = document.getElementById('pwWastedCost');
        const pwDemand = document.getElementById('pwDemandEffect');

        if (pwCarried) pwCarried.textContent = Math.round(carriedPct) + '%';
        if (pwWasted) {
            if (totalStrandedCostM > 0.5) {
                // Absolute $ amount bold, $/MWh as subtext
                pwWasted.innerHTML = '$' + (totalStrandedCostM >= 1000
                    ? (totalStrandedCostM / 1000).toFixed(1) + 'B'
                    : Math.round(totalStrandedCostM) + 'M');
                const wastedSub = pwWasted.closest('.pathway-metric')?.querySelector('.pathway-metric-sub');
                if (wastedSub) wastedSub.textContent = '$' + strandedPerMWh.toFixed(1) + '/MWh of demand';
                pwWasted.closest('.pathway-metric')?.classList.add('pathway-metric-warn');
            } else {
                pwWasted.textContent = '~$0';
                const wastedSub = pwWasted.closest('.pathway-metric')?.querySelector('.pathway-metric-sub');
                if (wastedSub) wastedSub.textContent = 'No stranded investment';
                pwWasted.closest('.pathway-metric')?.classList.remove('pathway-metric-warn');
            }
        }
        if (pwDemand) {
            if (demandOffset > 0.5) {
                pwDemand.textContent = '+' + Math.round(demandOffset) + ' pp';
            } else {
                pwDemand.textContent = 'Minimal';
            }
        }

        // Narrative
        if (insightBox) {
            const isoLabel = regionData.label?.split(' (')[0] || iso;
            let narrative = '';
            if (carriedPct >= 95) {
                narrative = `<strong>Nearly all interim investment carries forward.</strong> Moving from ` +
                    `<strong>${threshold}%</strong> to <strong>${longtermThreshold}%</strong> in ${isoLabel} ` +
                    `is highly capital-efficient â€” ${Math.round(carriedPct)}% of your ${Math.round(interimTWh)} TWh ` +
                    `interim portfolio remains useful at the ${Math.round(longtermTWh)} TWh long-term state.`;
            } else if (carriedPct >= 75) {
                const topStranded = strandedDetails.sort((a, b) => b.strandedTWh - a.strandedTWh)[0];
                narrative = `<strong>Most interim investment carries forward, with some rebalancing.</strong> ` +
                    `${Math.round(carriedPct)}% of your interim procurement remains useful.`;
                if (topStranded) {
                    narrative += ` The main shift: <strong>${topStranded.resource}</strong> has ` +
                        `${topStranded.strandedTWh.toFixed(1)} TWh of stranded capacity as the mix shifts toward ` +
                        `firm generation at ${longtermThreshold}%.`;
                }
                if (strandedPerMWh > 1) {
                    narrative += ` Building strategically toward ${longtermThreshold}% from the start could save ` +
                        `~<strong>$${strandedPerMWh.toFixed(1)}/MWh</strong> of stranded investment.`;
                }
            } else {
                narrative = `<strong>Significant portfolio restructuring required.</strong> ` +
                    `Only <strong>${Math.round(carriedPct)}%</strong> of the ${threshold}% portfolio carries ` +
                    `to the ${longtermThreshold}% end state.`;
                if (strandedDetails.length > 0) {
                    const topTwo = strandedDetails.sort((a, b) => b.strandedTWh - a.strandedTWh).slice(0, 2);
                    narrative += ` Biggest stranded assets: ` + topTwo.map(s =>
                        `<strong>${s.resource}</strong> (${s.strandedTWh.toFixed(1)} TWh excess)`
                    ).join(' and ') + '.';
                }
                if (strandedPerMWh > 2) {
                    narrative += ` This represents <strong>$${strandedPerMWh.toFixed(1)}/MWh</strong> of wasted ` +
                        `investment â€” the cost of optimizing for ${threshold}% instead of building toward ` +
                        `${longtermThreshold}% from day one.`;
                }
                if (demandOffset > 3) {
                    narrative += ` Demand growth of ${(annualRate * 100).toFixed(1)}%/yr helps absorb ` +
                        `<strong>${Math.round(demandOffset)} pp</strong> of surplus vs. static demand.`;
                }
            }
            insightBox.innerHTML = narrative;
        }
    } else {
        // No long-term target selected â€” show simpler insight, hide metrics
        if (metricsEl) metricsEl.style.display = 'none';
        if (insightBox) {
            let totalExistingTWh = 0;
            let totalTargetTWh = 0;
            MIX_RESOURCES.forEach(r => {
                totalExistingTWh += todayData.existing[r];
                totalTargetTWh += interimData.existing[r] + interimData.newBuild[r];
            });
            const newBuildTWh = totalTargetTWh - totalExistingTWh;
            // Dominant new resource
            let maxR = 'clean_firm', maxV = 0;
            MIX_RESOURCES.forEach(r => {
                if (interimData.newBuild[r] > maxV) { maxV = interimData.newBuild[r]; maxR = r; }
            });
            insightBox.innerHTML = `<strong>${iso}</strong> has <strong>${totalExistingTWh.toFixed(1)} TWh</strong> of existing clean energy. ` +
                `Reaching <strong>${threshold}%</strong> hourly matching by ${interimYear} requires ` +
                `<strong>${newBuildTWh.toFixed(1)} TWh</strong> of new procurement` +
                (maxV > 0.1 ? `, led by <strong>${MIX_LABELS_MAP[maxR]}</strong> at ${maxV.toFixed(1)} TWh.` : '.') +
                ` Select a <strong>long-term target</strong> above to see stranded investment analysis.`;
        }
    }
}

// ---- Pathway Analysis: demand growth + stranded investment ----

// ISO-specific annual demand growth rates (based on ISO forecasts and EIA/FERC data)
const DEMAND_GROWTH_RATES = {
    CAISO:  { Low: 0.014, Medium: 0.019, High: 0.025,
              label: 'CA electrification-driven' },
    ERCOT:  { Low: 0.020, Medium: 0.035, High: 0.055,
              label: 'TX data centers + population' },
    PJM:    { Low: 0.015, Medium: 0.024, High: 0.036,
              label: 'Data center corridor' },
    NYISO:  { Low: 0.013, Medium: 0.020, High: 0.044,
              label: 'CLCPA mandate-driven' },
    NEISO:  { Low: 0.009, Medium: 0.018, High: 0.029,
              label: 'Heating electrification' }
};

const RESOURCE_DISPLAY_NAMES = {
    clean_firm: 'Clean Firm',
    solar: 'Solar',
    wind: 'Wind',
    hydro: 'Hydro',
    storage: 'Storage',
    ccs_ccgt: 'CCS-CCGT',
    ldes: 'LDES',
    battery: 'Battery'
};

function initPathwayAnalysis() {
    const interimSel = document.getElementById('thresholdSelect');
    const longtermSel = document.getElementById('longtermTarget');
    const regionSel = document.getElementById('regionSelect');

    function populateLongtermOptions() {
        const interimVal = parseInt(interimSel.value, 10);
        const currentLtVal = longtermSel.value;
        longtermSel.innerHTML = '<option value="">Same as Interim</option>';

        const iso = regionSel.value;
        const region = DATA?.results?.[iso];
        if (!region) return;

        const available = Object.keys(region.thresholds).map(Number).sort((a, b) => a - b);
        available.forEach(t => {
            if (t > interimVal) {
                const opt = document.createElement('option');
                opt.value = String(t);
                opt.textContent = `${t}%`;
                longtermSel.appendChild(opt);
            }
        });

        if (currentLtVal && longtermSel.querySelector(`option[value="${currentLtVal}"]`)) {
            longtermSel.value = currentLtVal;
        }
    }

    // Re-render the unified panel when pathway controls change
    function triggerRerender() {
        updateDemandGrowthLabel();
        // Call the main dashboard update to re-render the WYN chart
        const iso = regionSel.value;
        const region = DATA?.results?.[iso];
        if (!region) return;
        const threshold = document.getElementById('thresholdSelect').value;
        const entry = resolveEntry(region, findClosestThreshold(region, threshold));
        if (entry) updateWhatYouNeedPanel(region, entry, threshold);
    }

    interimSel.addEventListener('change', () => {
        populateLongtermOptions();
        triggerRerender();
    });
    regionSel.addEventListener('change', () => {
        populateLongtermOptions();
        triggerRerender();
    });
    longtermSel.addEventListener('change', () => {
        triggerRerender();
        if (DATA) updateAll();
    });
    document.getElementById('interimYear')?.addEventListener('change', triggerRerender);
    document.getElementById('longtermYear')?.addEventListener('change', triggerRerender);

    const demandGrowthBtns = document.querySelectorAll('[data-toggle-group="demand_growth"]');
    demandGrowthBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('[data-toggle-group="demand_growth"]').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            triggerRerender();
        });
    });

    if (DATA) {
        populateLongtermOptions();
        // Default longterm target to 99%
        if (longtermSel.querySelector('option[value="99"]')) {
            longtermSel.value = '99';
        }
        updateDemandGrowthLabel();
    }
}

function getDemandGrowthLevel() {
    const activeBtn = document.querySelector('[data-toggle-group="demand_growth"].active');
    return activeBtn ? activeBtn.getAttribute('data-value') : 'Medium';
}

function updateDemandGrowthLabel() {
    const iso = document.getElementById('regionSelect').value;
    const display = document.getElementById('demandRateDisplay');
    if (!display || !iso) return;
    const rates = DEMAND_GROWTH_RATES[iso];
    if (!rates) { display.textContent = ''; return; }
    const level = getDemandGrowthLevel();
    const rate = rates[level] || rates.Medium;
    display.innerHTML = `<strong>${(rate * 100).toFixed(1)}%/yr</strong> â€” ${rates.label}`;
}

// updatePathwayAnalysis is now a no-op â€” all logic merged into updateWhatYouNeedPanel
function updatePathwayAnalysis() {
    updateDemandGrowthLabel();
}

// ---- Navigation Hamburger Menu ----
function initNavHamburger() {
    const hamburger = document.getElementById('navHamburger');
    const navLinks = document.getElementById('navLinks');
    if (hamburger && navLinks) {
        hamburger.addEventListener('click', function() {
            navLinks.classList.toggle('nav-open');
            // Toggle hamburger icon between menu and close
            const isOpen = navLinks.classList.contains('nav-open');
            this.innerHTML = isOpen
                ? '<svg viewBox="0 0 24 24"><line x1="6" y1="6" x2="18" y2="18"/><line x1="6" y1="18" x2="18" y2="6"/></svg>'
                : '<svg viewBox="0 0 24 24"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>';
        });
        // Close menu when a link is clicked (on mobile)
        navLinks.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', function() {
                if (window.innerWidth <= 768) {
                    navLinks.classList.remove('nav-open');
                    hamburger.innerHTML = '<svg viewBox="0 0 24 24"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>';
                }
            });
        });
    }
}

// ---- Boot ----
document.addEventListener('DOMContentLoaded', () => {
    loadData();
    initScrollAnimations();
    initNavHamburger();
});
</script>
</body>
</html>